---
layout:     post
title:      è®ºæ–‡ç›¸å…³
subtitle:   å•Šæˆ‘æ­»äº†ï¼Œä»»åŠ¡å¥½å¤š
date:       2019-07-13
author:     101142ts
header-img: img/post-bg-hacker.jpg
catalog: true
tags:
---


æ¯•ä¸šä¹Ÿæ¯•ä¸šäº†ï¼Œè¯¥ä¼‘æ¯ä¹Ÿä¼‘æ¯äº†ï¼Œè¯¥æ—…æ¸¸ä¹Ÿæ—…æ¸¸äº†ï¼Œæ„Ÿè§‰è‡ªå·±ä¸€å¹´æ²¡å¹²æ´»äº†ã€‚ä¸å¤šè¯´äº†ï¼Œæˆªç¨¿æ—¥10.7å·¦å³ï¼ŒåŠ æ²¹ðŸ’ª


## é¶å­
æˆ‘çš„è®ºæ–‡è¦ä»¥ä»£ç è¦†ç›–çŽ‡çš„æå‡ä¸ºå–ç‚¹ï¼Œæ–°å¼è„±å£³ç³»ç»Ÿä¸­ï¼š

### DroidUnpack

æµ‹è¯•æ ·æœ¬æœ€æ™šåˆ°2016å¹´

> DroidUnpack certainly suffers from limited cover coverage as it can only dump the code that executes.  

å¯»æ‰¾è¿™æ ·çš„ä¸€ç§æ ·æœ¬ï¼Œè¿™ç§æ ·æœ¬å­˜åœ¨è¢«åŠ å¯†çš„å­—èŠ‚ç ï¼Œä¸”è¿™ä¸ªå­—èŠ‚ç åœ¨ç¨‹åºç®€å•æ‰§è¡Œæ—¶å¹¶ä¸ä¼šè¢«æ‰§è¡Œåˆ°ï¼šç™¾åº¦çš„onCreateæ ·æœ¬

> And since it is built on top of whole-system emulation, packers that enforce anti-emulation techniques will inevitably break the analysis.

åè°ƒè¯•æ ·æœ¬å¤§æ¦‚æŒºå¤šçš„ï¼Ÿ

### PackerGrind

æµ‹è¯•æ ·æœ¬æ˜¯2015å¹´ä¸‰æœˆåˆ°2016å¹´ä¸‰æœˆ

> PackerGrind can unpack apps protected by all mechanisms except the Re-implement Method.

Re-implement Method å³æ˜¯ç™¾åº¦çš„onCreate

PackerGrindä¸­æåˆ°çš„å¯¹äºŽDexHunterçš„æµ‹è¯•

> DexHunter cannot correctly recover the Dex files for samples
from Qihoo, Baidu and Ijiami. For Qihoo samples, the
Dex files dumped by DexHunter only contain stub classes
instead of real code, such as com.qihoo.util.Configuration and
com.qihoo.util.StubApplication, because Qihoo packer uses
its own functions instead of runtime methods monitored by
DexHunter to load classes. For Baidu samples, the Dex files
dumped by DexHunter cannot be disassembled because their
Dex headers have been modified by the packed apps. Hence,
they cannot be recognized by de-compilers. DexHunter also
cannot recover the original Dalvik bytecodes of onCreate(). For
Ijiami samples, DexHunter cannot unpack them successfully
due to the time-out checking mechanism utilized by Ijiami.
More precisely, the packed apps will check the existence of a
long-running task, which exceeds a time threshold, and exit if
found. Therefore, the process of DexHunter will stop because
its unpacking operations takes such a long time that the packed
app exits quickly.

PackerGrindçš„çŸ­æ¿
> PackerGrind can only recover the Dex data after the methods
for releasing the real code are invoked. The majority of
existing packers execute such methods, which are usually JNI
methods, when a packed app is launched to avoid performance
degradation. We also use IntelliDroid [25] to trigger the
execution of such methods. Since packers may delay the
execution of such methods after knowing the mechanism of
PackerGrind we will leverage advanced input generator for
Android [52], [53] to enhance PackerGrind in future work.  
> PackerGrind is based on Valgrind. Similar to the antiemulator
methods, packed apps may detect the existences
of PackerGrind and then cease releasing the real code. For
example, they could check the app starting command or count
the time used to finish some operations. To address this issue,
we could change the return value of selected APIs to hide the
existence of PackerGrind or insert additional IR statements
to modify the registers and force the app to execute forward.

PackerGrindä¸­å¯¹äºŽæ¶æ„è½¯ä»¶çš„å™è¿°å€¼å¾—å­¦ä¹ ï¼Œæ¶æ„è½¯ä»¶è¢«åŠ å£³ä¹‹åŽå¯ä»¥éšè—æ•æ„Ÿè¡Œä¸ºï¼Œè€Œè¢«è„±å£³ä¹‹åŽæ•æ„Ÿè¡Œä¸ºæ‰ä¼šè¢«é‡æ–°æš´éœ²ã€‚

## å­˜åœ¨çš„é—®é¢˜

å¼ºåˆ¶åå°„è°ƒç”¨nativeæ–¹æ³•

è¯´å®žéªŒçš„æ—¶å€™æ€Žä¹ˆè¯´ï¼Ÿè¯´2018~2019å¹´çš„è‚¯å®šä¸okï¼Œå› ä¸ºç›®å‰åŸºæœ¬éƒ½æ˜¯ç”¨å†…å­˜å£³+vmpçš„å½¢å¼

## è°ƒæŸ¥æ‰‹æ®µ

googleæœç´¢åŠ å›ºå…³é”®å­—

- site: çœ‹é›ªè®ºå›

## å·²çŸ¥çš„æƒ…æŠ¥

360è‡³å°‘ä»Ž2017å¹´å¼€å§‹å°±å¼€å§‹ä½¿ç”¨vmpæŠ€æœ¯ä¿æŠ¤ [è¿™é‡Œ](https://bbs.pediy.com/thread-223223.htm)

2018-03-28 çœ‹é›ªä¸Šçš„æƒ…æŠ¥

> ä¸çŸ¥é“ä½ çš„çˆ±åŠ å¯†æ ·æœ¬æ˜¯ä»€ä¹ˆç‰ˆæœ¬ï¼Œæˆ‘è¯´çš„çˆ±åŠ å¯†æ–¹æ³•æŠ½å–ç±»æ˜¯è¿™æ ·çš„ï¼šè°ƒç”¨å‰è§£å¯†smaliä»£ç ï¼Œè°ƒç”¨åŽé©¬ä¸ŠåˆåŠ å¯†smaliä»£ç ã€‚ dexdump çš„ä½œè€…çŸ¥é“æˆ‘æžè¿‡çˆ±åŠ å¯†çš„å£³ï¼Œå°±æ˜¯é‡‡ç”¨hookç„¶åŽè¿˜åŽŸçš„ã€‚
æ®æˆ‘æ‰€çŸ¥ï¼Œdexhunterèƒ½è¿˜åŽŸçš„æ–¹æ³•æŠ½å–ç±»æ˜¯è¿™æ ·çš„ï¼šè°ƒç”¨å‰è§£å¯†smaliä»£ç ï¼Œè°ƒç”¨åŽå°±ä¸å†åŠ å¯†äº†ã€‚ 

2016-07-28 çœ‹é›ªä¸Šçš„æƒ…æŠ¥
> æˆ‘è®°å¾—14å¹´æˆ‘å‚è§é˜¿é‡Œæ¯”èµ›çš„æ—¶å€™ï¼Œé˜¿é‡Œçš„å£³å°±æ˜¯è¿™ä¸ªæ ·å­ï¼Œè¿™éƒ½16å¹´äº†ï¼Œæ€Žä¹ˆè¿˜æ˜¯è¿™æ ·ï¼Œè¿˜åªæ˜¯ä¿®æ”¹codeffï¼Œéƒ½æ²¡æœ‰åŠ¨æ€åˆ†é…å†…å­˜æŠŠæ–¹æ³•æ•°æ®åˆ†å¼€å­˜æ”¾ã€‚ä¸è¿‡ä¼°è®¡è¿™æ˜¯ç»™ä¸ªäººå¼€å‘è€…æä¾›çš„å…è´¹å£³å§ï¼Œå•†ä¸šå£³çŽ°åœ¨éƒ½ä¸Švmpäº†ã€‚

2017-09-17 é¡¶è±¡åŠ å›º java to c

2017-01-2 çˆ±åŠ å¯†
> çœ‹ä¸€ä¸‹com.cioubç±»çš„clinitæ–¹æ³•çš„å®žçŽ°å°±æ˜Žç™½äº†ï¼Œä¸Šé¢æåˆ°çš„é‚£äº›åžƒåœ¾ç±»ï¼ˆjpvbhnã€cioubã€flsyeâ€¦ï¼‰éƒ½æ˜¯*****ä¸ºäº†â€œé˜²DexHunterâ€æ·»åŠ çš„ã€‚

cioubç±»ä¸­å­˜åœ¨exit

å­˜åœ¨libexecmain.soå’Œlibexec.so

## è¿›åº¦
7.13~7.14 åœ¨googleä¸Šä»¥ **åŠ å›º åŠ å£³ android site:https://www.pediy.com/** å…³é”®å­—è¿›è¡Œæœç´¢ï¼Œçœ‹äº†10é¡µï¼Œæ²¡æœ‰çœ‹åˆ°ä»»ä½•ä¸Žå¤šå±‚æ¬¡è§£å¯†æœ‰å…³çš„ä¿¡æ¯ï¼Œåªæœ‰çˆ±åŠ å¯†ä¼ä¸šç‰ˆå¯èƒ½æœ‰è¿™ä¸ªç‰¹æ€§

DroidUnpackè®ºæ–‡åŽŸæ–‡

> **Multi-layer unpacking**. Many Android unpackers, depend on an assumption that there exists a clear boundary
between packerâ€™s code and original code within packed apps
to function normally. However, according to our observation,
this assumption no longer holds. According to our study, many
commercial packers turn to multi-layer unpacking strategy,
meaning other than unpacking the original code at once and
loading into memory, they unpack the original code layer
by layer during execution. This technique will obviously
render the current memory dump based unpackers useless
since the dumped memory will contain mostly the unreadable
packed code other than the original code. Table II shows
that Bangcle, ijiami, Qihoo and Tencent adopt this
unpacking technique, among which, Tencent is the most
complex one.

åŒ…æ‹¬åœ¨æåˆ°è¿›åŒ–ä¸­ä¹Ÿæåˆ°äº†ï¼Œè„±å£³çš„å±‚æ•°è¶Šæ¥è¶Šå¤šï¼Œä¸è¿‡è¿™ä¸ªå±‚æ•°æ˜¯ä»Ž2010~2015å¹´æ¥è¯´çš„ï¼Œç›¸å¯¹äºŽçŽ°åœ¨2019å¹´æ¥è¯´ï¼Œæœ‰ç‚¹æ°´

> **Number of unpacking layers**. We have seen multi-layer
unpacking in commercial packers, but we havenâ€™t seen such
complicated unpacking process as shown in Figure 5. In
year 2015, there exist about 1.3% of custom packed Android
malware that unpack their hidden code with more than 1000
layers. This level of complication is never observed in commercial
packers and certainly brings tremendous difficulty for
unpackers to operate. In contrast, the most complicated custom
packed malware we have in year 2010 has only 6 layers. The
ratio of packed malware that equip with 10 or more layers
unpacking has grown from 0% in 2010 to 24.73% in 2015
which is a clear indicator that Android custom packers have
been evolving in a fast pace.