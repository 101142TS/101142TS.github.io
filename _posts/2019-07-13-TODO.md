---
layout:     post
title:      è®ºæ–‡ç›¸å…³
subtitle:   å•Šæˆ‘æ­»äº†ï¼Œä»»åŠ¡å¥½å¤š
date:       2019-07-13
author:     101142ts
header-img: img/post-bg-hacker.jpg
catalog: true
tags:
---


æ¯•ä¸šä¹Ÿæ¯•ä¸šäº†ï¼Œè¯¥ä¼‘æ¯ä¹Ÿä¼‘æ¯äº†ï¼Œè¯¥æ—…æ¸¸ä¹Ÿæ—…æ¸¸äº†ï¼Œæ„Ÿè§‰è‡ªå·±ä¸€å¹´æ²¡å¹²æ´»äº†ã€‚ä¸å¤šè¯´äº†ï¼Œæˆªç¨¿æ—¥10.7å·¦å³ï¼ŒåŠ æ²¹ğŸ’ª


## é¶å­
æˆ‘çš„è®ºæ–‡è¦ä»¥ä»£ç è¦†ç›–ç‡çš„æå‡ä¸ºå–ç‚¹ï¼Œæ–°å¼è„±å£³ç³»ç»Ÿä¸­ï¼š

### DroidUnpack

æµ‹è¯•æ ·æœ¬æœ€æ™šåˆ°2016å¹´

> DroidUnpack certainly suffers from limited cover coverage as it can only dump the code that executes.  

å¯»æ‰¾è¿™æ ·çš„ä¸€ç§æ ·æœ¬ï¼Œè¿™ç§æ ·æœ¬å­˜åœ¨è¢«åŠ å¯†çš„å­—èŠ‚ç ï¼Œä¸”è¿™ä¸ªå­—èŠ‚ç åœ¨ç¨‹åºç®€å•æ‰§è¡Œæ—¶å¹¶ä¸ä¼šè¢«æ‰§è¡Œåˆ°ï¼šç™¾åº¦çš„onCreateæ ·æœ¬

> And since it is built on top of whole-system emulation, packers that enforce anti-emulation techniques will inevitably break the analysis.

åè°ƒè¯•æ ·æœ¬å¤§æ¦‚æŒºå¤šçš„ï¼Ÿ

### PackerGrind

æµ‹è¯•æ ·æœ¬æ˜¯2015å¹´ä¸‰æœˆåˆ°2016å¹´ä¸‰æœˆ

> PackerGrind can unpack apps protected by all mechanisms except the Re-implement Method.

Re-implement Method å³æ˜¯ç™¾åº¦çš„onCreate

PackerGrindä¸­æåˆ°çš„å¯¹äºDexHunterçš„æµ‹è¯•

> DexHunter cannot correctly recover the Dex files for samples
from Qihoo, Baidu and Ijiami. For Qihoo samples, the
Dex files dumped by DexHunter only contain stub classes
instead of real code, such as com.qihoo.util.Configuration and
com.qihoo.util.StubApplication, because Qihoo packer uses
its own functions instead of runtime methods monitored by
DexHunter to load classes. For Baidu samples, the Dex files
dumped by DexHunter cannot be disassembled because their
Dex headers have been modified by the packed apps. Hence,
they cannot be recognized by de-compilers. DexHunter also
cannot recover the original Dalvik bytecodes of onCreate(). For
Ijiami samples, DexHunter cannot unpack them successfully
due to the time-out checking mechanism utilized by Ijiami.
More precisely, the packed apps will check the existence of a
long-running task, which exceeds a time threshold, and exit if
found. Therefore, the process of DexHunter will stop because
its unpacking operations takes such a long time that the packed
app exits quickly.

PackerGrindçš„çŸ­æ¿
> PackerGrind can only recover the Dex data after the methods
for releasing the real code are invoked. The majority of
existing packers execute such methods, which are usually JNI
methods, when a packed app is launched to avoid performance
degradation. We also use IntelliDroid [25] to trigger the
execution of such methods. Since packers may delay the
execution of such methods after knowing the mechanism of
PackerGrind we will leverage advanced input generator for
Android [52], [53] to enhance PackerGrind in future work.  
> PackerGrind is based on Valgrind. Similar to the antiemulator
methods, packed apps may detect the existences
of PackerGrind and then cease releasing the real code. For
example, they could check the app starting command or count
the time used to finish some operations. To address this issue,
we could change the return value of selected APIs to hide the
existence of PackerGrind or insert additional IR statements
to modify the registers and force the app to execute forward.

PackerGrindä¸­å¯¹äºæ¶æ„è½¯ä»¶çš„å™è¿°å€¼å¾—å­¦ä¹ ï¼Œæ¶æ„è½¯ä»¶è¢«åŠ å£³ä¹‹åå¯ä»¥éšè—æ•æ„Ÿè¡Œä¸ºï¼Œè€Œè¢«è„±å£³ä¹‹åæ•æ„Ÿè¡Œä¸ºæ‰ä¼šè¢«é‡æ–°æš´éœ²ã€‚

PackerGrindæå‡ä»£ç è¦†ç›–ç‡çš„æ–¹æ³•ï¼š

> The majority of
existing packers execute such methods, which are usually JNI
methods, when a packed app is launched to avoid performance
degradation. We also use IntelliDroid [25] to trigger the
execution of such methods.
## å­˜åœ¨çš„é—®é¢˜

å¼ºåˆ¶åå°„è°ƒç”¨nativeæ–¹æ³•

è¯´å®éªŒçš„æ—¶å€™æ€ä¹ˆè¯´ï¼Ÿè¯´2018~2019å¹´çš„è‚¯å®šä¸okï¼Œå› ä¸ºç›®å‰åŸºæœ¬éƒ½æ˜¯ç”¨å†…å­˜å£³+vmpçš„å½¢å¼

## è°ƒæŸ¥æ‰‹æ®µ

googleæœç´¢åŠ å›ºå…³é”®å­—

- site: çœ‹é›ªè®ºå›

## å·²çŸ¥çš„æƒ…æŠ¥

360è‡³å°‘ä»2017å¹´å¼€å§‹å°±å¼€å§‹ä½¿ç”¨vmpæŠ€æœ¯ä¿æŠ¤ [è¿™é‡Œ](https://bbs.pediy.com/thread-223223.htm)

2018-03-28 çœ‹é›ªä¸Šçš„æƒ…æŠ¥

> ä¸çŸ¥é“ä½ çš„çˆ±åŠ å¯†æ ·æœ¬æ˜¯ä»€ä¹ˆç‰ˆæœ¬ï¼Œæˆ‘è¯´çš„çˆ±åŠ å¯†æ–¹æ³•æŠ½å–ç±»æ˜¯è¿™æ ·çš„ï¼šè°ƒç”¨å‰è§£å¯†smaliä»£ç ï¼Œè°ƒç”¨åé©¬ä¸ŠåˆåŠ å¯†smaliä»£ç ã€‚ dexdump çš„ä½œè€…çŸ¥é“æˆ‘æè¿‡çˆ±åŠ å¯†çš„å£³ï¼Œå°±æ˜¯é‡‡ç”¨hookç„¶åè¿˜åŸçš„ã€‚
æ®æˆ‘æ‰€çŸ¥ï¼Œdexhunterèƒ½è¿˜åŸçš„æ–¹æ³•æŠ½å–ç±»æ˜¯è¿™æ ·çš„ï¼šè°ƒç”¨å‰è§£å¯†smaliä»£ç ï¼Œè°ƒç”¨åå°±ä¸å†åŠ å¯†äº†ã€‚ 

2016-07-28 çœ‹é›ªä¸Šçš„æƒ…æŠ¥
> æˆ‘è®°å¾—14å¹´æˆ‘å‚è§é˜¿é‡Œæ¯”èµ›çš„æ—¶å€™ï¼Œé˜¿é‡Œçš„å£³å°±æ˜¯è¿™ä¸ªæ ·å­ï¼Œè¿™éƒ½16å¹´äº†ï¼Œæ€ä¹ˆè¿˜æ˜¯è¿™æ ·ï¼Œè¿˜åªæ˜¯ä¿®æ”¹codeffï¼Œéƒ½æ²¡æœ‰åŠ¨æ€åˆ†é…å†…å­˜æŠŠæ–¹æ³•æ•°æ®åˆ†å¼€å­˜æ”¾ã€‚ä¸è¿‡ä¼°è®¡è¿™æ˜¯ç»™ä¸ªäººå¼€å‘è€…æä¾›çš„å…è´¹å£³å§ï¼Œå•†ä¸šå£³ç°åœ¨éƒ½ä¸Švmpäº†ã€‚

2017-09-17 é¡¶è±¡åŠ å›º java to c

2017-01-2 çˆ±åŠ å¯†
> çœ‹ä¸€ä¸‹com.cioubç±»çš„clinitæ–¹æ³•çš„å®ç°å°±æ˜ç™½äº†ï¼Œä¸Šé¢æåˆ°çš„é‚£äº›åƒåœ¾ç±»ï¼ˆjpvbhnã€cioubã€flsyeâ€¦ï¼‰éƒ½æ˜¯*****ä¸ºäº†â€œé˜²DexHunterâ€æ·»åŠ çš„ã€‚

cioubç±»ä¸­å­˜åœ¨exit

å­˜åœ¨libexecmain.soå’Œlibexec.so

## è¿›åº¦
7.13~7.14 åœ¨googleä¸Šä»¥ **åŠ å›º åŠ å£³ android site:https://www.pediy.com/** å…³é”®å­—è¿›è¡Œæœç´¢ï¼Œçœ‹äº†10é¡µï¼Œæ²¡æœ‰çœ‹åˆ°ä»»ä½•ä¸å¤šå±‚æ¬¡è§£å¯†æœ‰å…³çš„ä¿¡æ¯ï¼Œåªæœ‰çˆ±åŠ å¯†ä¼ä¸šç‰ˆå¯èƒ½æœ‰è¿™ä¸ªç‰¹æ€§

DroidUnpackè®ºæ–‡åŸæ–‡

> **Multi-layer unpacking**. Many Android unpackers, depend on an assumption that there exists a clear boundary
between packerâ€™s code and original code within packed apps
to function normally. However, according to our observation,
this assumption no longer holds. According to our study, many
commercial packers turn to multi-layer unpacking strategy,
meaning other than unpacking the original code at once and
loading into memory, they unpack the original code layer
by layer during execution. This technique will obviously
render the current memory dump based unpackers useless
since the dumped memory will contain mostly the unreadable
packed code other than the original code. Table II shows
that Bangcle, ijiami, Qihoo and Tencent adopt this
unpacking technique, among which, Tencent is the most
complex one.

åŒ…æ‹¬åœ¨æåˆ°è¿›åŒ–ä¸­ä¹Ÿæåˆ°äº†ï¼Œè„±å£³çš„å±‚æ•°è¶Šæ¥è¶Šå¤šï¼Œä¸è¿‡è¿™ä¸ªå±‚æ•°æ˜¯ä»2010~2015å¹´æ¥è¯´çš„ï¼Œç›¸å¯¹äºç°åœ¨2019å¹´æ¥è¯´ï¼Œæœ‰ç‚¹æ°´

> **Number of unpacking layers**. We have seen multi-layer
unpacking in commercial packers, but we havenâ€™t seen such
complicated unpacking process as shown in Figure 5. In
year 2015, there exist about 1.3% of custom packed Android
malware that unpack their hidden code with more than 1000
layers. This level of complication is never observed in commercial
packers and certainly brings tremendous difficulty for
unpackers to operate. In contrast, the most complicated custom
packed malware we have in year 2010 has only 6 layers. The
ratio of packed malware that equip with 10 or more layers
unpacking has grown from 0% in 2010 to 24.73% in 2015
which is a clear indicator that Android custom packers have
been evolving in a fast pace.

7.17

æœ‰å…³Appspearçš„ä»‹ç» [è¿™é‡Œ](https://zhuanlan.zhihu.com/p/21911495)

åŸºæœ¬ä¸Šå°±æ˜¯ä¸ªå†…å­˜dump

> è„±å£³çš„æœ¬è´¨æ˜¯å»è·å–ç¨‹åºçœŸå®çš„è¡Œä¸ºï¼Œå› æ­¤æ’æ¡©ä»£ç å…¶å®å°±æ˜¯å»å¾—åˆ°å†…å­˜ä¸­çš„Dalvikæ•°æ®ç»“æ„ï¼Œæ¥åæ˜ è¢«æ‰§è¡Œçš„çœŸå®ä»£ç ã€‚åœ¨æŒ‡ä»¤æ‰§è¡Œæ—¶å¯ä»¥ç›´æ¥å¾—åˆ°è¯¥æ¡æŒ‡ä»¤å±äºçš„æ–¹æ³•ï¼ŒMethodè¿™ä¸ªç»“æ„ã€‚è€Œæ¯ä¸ªè¢«æ‰§è¡Œçš„æ–¹æ³•ä¸­éƒ½æœ‰è¯¥æ–¹æ³•å±äºçš„ç±»å¯¹è±¡clazzï¼Œè€Œclazzï¼ˆæºç ç›®å½•dalvik/vm/oo/Object.hï¼‰ä¸­åˆæœ‰pDvmDexï¼ˆdalvik/vm/DvmDex.hï¼‰å¯¹è±¡ï¼Œå…¶ä¸­æœ‰pDexFileï¼ˆdalvik/libdex/DexFile.hï¼‰ç»“æ„ä½“ä»£è¡¨äº†DEXæ–‡ä»¶ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæ‰§è¡Œè¿‡ç¨‹ä¸­è·å–å½“å‰æ–¹æ³•åï¼Œç”¨curMethod->clazz->pDvmDex->pDexFileå°±èƒ½å¤Ÿå¾—åˆ°è¿™ä¸ªæ–¹æ³•å±äºçš„DEXæ–‡ä»¶ç»“æ„ã€‚è¯¥ç»“æ„ä½“ä¸­åŒ…å«äº†æ‰€æœ‰DEXæ–‡ä»¶åœ¨è§£é‡Šå…¶ä¸­è¢«æ‰§è¡Œæ—¶çš„å†…å­˜ä¿¡æ¯ï¼Œé€šè¿‡è§£æè¿™ä¸ªDexFileç»“æ„ä½“å°±èƒ½æ¢å¤å‡ºæœ€çœŸå®çš„DEXã€‚

æåˆ°äº†ç™¾åº¦çš„onCreate001æ ·æœ¬ï¼š

> å¦å¤–è¿˜æœ‰å£³æ˜¯é‡å†™äº†æŸäº›æ–¹æ³•ï¼Œå°†ä»£ç æ”¾å…¥ä¸€ä¸ªæ–°çš„æ–¹æ³•ä¸­ï¼Œå¹¶åœ¨æ‰§è¡Œå‰å»è§£å¯†ï¼Œæ‰§è¡Œåå†é‡æ–°æŠ¹å»ã€‚å¯¹äºè¿™ç§æƒ…å†µï¼Œç”±äºæˆ‘ä»¬è„±å£³ä»£ç æ’æ¡©äºæ¯ä¸ªæ–¹æ³•è°ƒç”¨å¤„ï¼Œå› æ­¤æˆ‘ä»¬åªéœ€è¦è°ƒæ•´è„±å£³ç‚¹åˆ°è¯¥æ–¹æ³•æ‰§è¡Œå¤„å»å®æ–½è„±å£³å°±èƒ½æ¢å¤å‡ºä»£ç äº†ã€‚

7.18
æœ‰å…³æ¶æ„è½¯ä»¶ä½¿ç”¨packingçš„å¼•ç”¨

Detection of Repackaged Android Malware with Code-Heterogeneity Features æåˆ°äº†

> There is a trend that malware writers tend to abuse packing services to evade malware screening. Malware adopts code packing techniques to prevent the analyst from acquiring app bytecode.

Andro-Dumpsys: Anti-malware system based on the similarity of malware creator and malware centric information æåˆ°äº†

> However, along with this development, anti-malware analysis techniques, such as packing, dynamic loading, and dex encryption, have seen wide adoption, making existing malware-centric analysis methods less effective. 

7.20

å¼€å§‹å¯»æ‰¾å°½å¯èƒ½ç¬¦åˆæˆ‘è¦æ±‚çš„æ ·æœ¬ï¼šæœ‰å››å¤§ç»„ä»¶ï¼Œæœ‰åŠ¨æ€ç±»åŠ è½½å’ŒJniå‡½æ•°è°ƒç”¨

2048ï¼šå°±æ˜¯ä¸ªç®€å•çš„Activity,è°ƒç”¨æœ¬åœ°çš„htmlï¼Œhtmlé‡Œé¢å†ç”¨jsè¿˜æ˜¯å•¥çš„æ¥å†™

9.5

å‰é¢é‚£æ®µæ—¶é—´åšäº†å…³äºå…è´¹å£³çš„å®éªŒ

ä¸‹é¢ä¸»è¦æ˜¯å†™è®ºæ–‡ï¼Œå¯¹äºæˆ‘çš„æ–¹æ³•è€Œè¨€ï¼Œé¦–å…ˆè¦è·å¾—ä¸€ä¸ªåˆå§‹çš„pDexFile, æœ‰äº†pDexFileä»¥åï¼Œå„ç§æ•°æ®æ”¶é›†å’Œå¼ºåˆ¶åå°„è°ƒç”¨æ–¹æ³•çš„æ•…äº‹æ‰èƒ½ç»§ç»­å¾€ä¸‹è¯´ã€‚

[è·å¾—pDexFileçš„æ–¹æ³•](https://www.jianshu.com/p/ab9c3984d995)

dalvikè™šæ‹ŸæœºåŠ è½½dexæ–‡ä»¶æ—¶ï¼Œä¼šä½¿ç”¨Dalvik_dalvik_system_DexFile_openDexFileNativeå‡½æ•°ï¼Œè¯¥å‡½æ•°å°è¯•æŠŠå‚æ•°çš„æ–‡ä»¶å½“æˆåç¼€ä¸º.dexçš„æ–‡ä»¶æ‰“å¼€ï¼Œå¦‚æœæ‰“å¼€å¤±è´¥çš„è¯ï¼Œåˆ™æŠŠå®ƒå½“åšä¸€ä¸ªåŒ…å«æœ‰classes.dexæ–‡ä»¶çš„Zipæ–‡ä»¶è¿›è¡Œæ‰“å¼€ã€‚

æ‰“å¼€ä»¥åï¼Œå­˜å‚¨åˆ°pDexOrJarä¸­ï¼Œå¹¶ç”¨addToDexFileTableæœ€ç»ˆæ·»åŠ åˆ°gDvmä¸­çš„userDexFileç»“æ„çš„hashè¡¨ä¸­ã€‚

gDvmæ˜¯ä¸€ä¸ªDvmGlobalsç»“æ„çš„å…¨å±€å˜é‡ã€‚åœ¨DvmGlobalsç»“æ„ä¸­æœ‰ä¸€ä¸ªæˆå‘˜HashTable* userDexFiles; HashTableä¸­æœ‰ä¸€ä¸ªHashEntry* pEntriesæŒ‡å‘ä¸€ä¸ªHashEntryçš„æ•°ç»„,HashEntryç»“æ„ä½“ä¸­çš„dataå˜é‡å­˜æ”¾çš„å°±æ˜¯pDexOrJarã€‚

[è·å¾—pDexFileçš„classloaderçš„æ–¹æ³•](https://www.jianshu.com/p/23031578e654)

gDvm.loadedClasseså­˜å‚¨ç€æ‰€æœ‰è¢«åŠ è½½çš„ç±»ï¼ŒåŠ è½½çš„ç±»é€šè¿‡dvmAddClassToHashè¢«æ·»åŠ åˆ°gDvm.loadedClassesä¸­ï¼Œæ·»åŠ ç±»çš„æ–¹æ³•å’Œæ·»åŠ pDexFileçš„æ–¹æ³•ä¸€æ ·ï¼Œéƒ½æ˜¯ç”¨dvmHashTableLookupæ·»åŠ çš„

9.8

nativeæ–¹æ³•çš„æ‰§è¡Œè¿‡ç¨‹

nativeæ–¹æ³•æœ‰ä¸¤ç§æ³¨å†Œæ–¹å¼ï¼Œä¸€ç§æ˜¯é™æ€çš„æ³¨å†Œæ–¹å¼ï¼Œå³é€šè¿‡å‡½æ•°ååœ¨soä¸­è‡ªå·±å»å¯»æ‰¾å¯¹åº”çš„nativeæ–¹æ³•ã€‚ä¸€ç§æ˜¯åŠ¨æ€çš„æ³¨å†Œæ–¹å¼ã€‚

é™æ€æ³¨å†Œæ–¹å¼ï¼š

åœ¨loadMethodFromDexä¸­ï¼Œå¦‚æœmethodæ˜¯nativeçš„è¯ï¼Œé¦–å…ˆmeth->nativeFunc = dvmResolveNativeMethod
åœ¨è¯¥methodç¬¬ä¸€æ¬¡çœŸæ­£è¿è¡Œçš„æ—¶å€™
(\*method->nativeFunc)((u4\*)self->interpSave.curFrame, pResult, method, self);
æ­¤æ—¶meth->nativeFunc æ˜¯ dvmResolveNativeMethod
åœ¨dvmResolveNativeMethodå†…ï¼Œé¦–å…ˆæ£€æŸ¥è¿™ä¸ªå‡½æ•°æ˜¯ä¸æ˜¯å†…éƒ¨Nativeå‡½æ•°dvmLookupInternalNativeMethod
ç„¶åä½¿ç”¨lookupSharedLibMethodæ‰«ææ‰€æœ‰åŠ è½½äº†çš„DLLsï¼Œå¦‚æœæ‰¾åˆ°äº†
if (func != NULL) {
    /* found it, point it at the JNI bridge and then call it */
    dvmUseJNIBridge((Method*) method, func);            //è¿™é‡Œçš„funcæ˜¯å‡½æ•°æŒ‡é’ˆ
    (*method->nativeFunc)(args, pResult, method, self);
    return;
}
åœ¨dvmUseJNIBridgeä¸­
DalvikBridgeFunc bridge = gDvmJni.useCheckJni ? dvmCheckCallJNIMethod : dvmCallJNIMethod;
dvmSetNativeFunc(method, bridge, (const u2*) func);
ä¸€èˆ¬æ¥è¯´gDvmJni.useCheckJniä¸ºfalse, æ•…bridgeä¸ºdvmCallJNIMethod
åœ¨dvmSetNativeFuncä¸­ï¼Œå¦‚æœfuncä¸ä¸ºç©ºï¼Œåˆ™å®è´¨æ˜¯å°†funcèµ‹å€¼ç»™method->insnsï¼Œä¸”å°†method->nativeFuncå˜æˆdvmCallJNIMethod
æ•…é™æ€æ³¨å†Œæ–¹å¼é‡Œé¢ï¼Œæœ€å(*method->nativeFunc)(args, pResult, method, self);å®è´¨æ˜¯dvmCallJNIMethod

åŠ¨æ€æ³¨å†Œæ–¹å¼ï¼š

ä½¿ç”¨JNIEnv.RegisterNativesæ¥å®Œæˆæ³¨å†Œ

static jint RegisterNatives(JNIEnv* env, jclass jclazz,
    const JNINativeMethod* methods, jint nMethods)
{
    ...
    for (int i = 0; i < nMethods; i++) {
        if (!dvmRegisterJNIMethod(clazz, methods[i].name,
                methods[i].signature, methods[i].fnPtr))
        {
            return JNI_ERR;
        }
    }
    return JNI_OK;
}
åœ¨dvmRegisterJNIMethodä¸­ï¼Œæœ€ç»ˆè°ƒç”¨äº†dvmUseJNIBridge(method, fnPtr); æ³¨å†Œæµç¨‹æ˜¯ä¸€æ ·çš„

ä¹Ÿå°±æ˜¯è¯´ï¼Œæœ€åæ‰§è¡Œçš„æ—¶å€™ï¼Œä¸€å®šä¼šåˆ°dvmCallJNIMethodï¼Œæ•…åœ¨dvmCallJNIMethodå†…è¿›è¡Œç›‘æ§ã€‚

