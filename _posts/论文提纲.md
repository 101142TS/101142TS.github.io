# Abstract

近年来，Android加壳服务被广泛使用。为了分析被加壳的应用，研究者们提出了一系列脱壳方法。这些脱壳方法可分为两类：

第一类脱壳方法在应用运行到达一定状态后，转储内存，重新拼接得到脱壳后的dex。这类方法假设在某一状态，所有加密代码都被解密释放到内存。但如今，加壳服务已经实现运行阶段多层次解密，这类脱壳方法无法保证存在这样可以脱壳的特定状态并能成功触发该状态。

第二类脱壳方法通过监控加壳应用运行过程，在加壳服务释放真实代码或执行函数时，收集函数代码重组得到dex。但这类脱壳方法无法保证所有被加壳服务加密的代码在运行过程中都被释放或执行。因此脱壳得到的dex文件可能并不完整

为了解决目前脱壳方法中存在的问题，我们提出了一种全新的通用脱壳方法，并实现了Rupk系统。Rupk假设Android函数运行过程中，函数处于解密状态。为了让所有函数均被执行，Rupk创造性地强制执行所有函数，提高代码覆盖率。Rupk通过构建参数，反射调用目标函数，实现对目标函数的强制调用。在函数触发异常前，Rupk提取函数被还原后的代码，用于重组dex。同时，Rupk利用异常捕获机制，将崩溃次数降低到XXX%，并通过状态记录，在崩溃后重启应用，强制调用后续函数，继续脱壳进程。

在XXX个覆盖20XX-20XX时间上的加壳样本上进行实验，XXXX个方法中，XXX%方法能够被还原代码，证明了Rupk的有效性。进一步，我们实验还表明，Rupk还能处理以往脱壳系统无法处理的函数运行前解密、运行后加密的加壳方法。

# Introduction 

Android是市场上份额最高的移动操作系统，根据IDC的统计，2018年android手机的全球出货量在总出货量中的占比为85.1%，远超其他系统手机。为了保护Android应用免受逆向和篡改，出现了一系列加壳服务。虽然这些加壳服务保护了应用，但恶意软件也在滥用加壳服务，以躲避安全检测和研究人员的分析。除此以外，加壳后的应用也难以被分析漏洞、隐私泄漏等安全问题。

为了解决上述问题，研究者们提出了一系列脱壳方法，还原被加壳的应用。这些方法可大致分为两类：

第一类方法假设加壳应用运行的过程中存在一个合适的状态，dex所有加密代码都被解密释放到内存中，在此状态处转储内存，重新拼接可以得到脱壳后的dex。我们将这类方法称为基于合适状态(Right timing)的脱壳。这类方法出现较早，2015年的AppSpear和DexHunter。这类方法刚出现时都取得了不错的脱壳效果，但如今，加壳服务不断发展变化，并已经实现运行阶段多层次解密。这类脱壳方法无法保证:1)存在这样可以脱壳的特定状态；2）能成功触发该状态；3）加壳软件在更新的版本中不会导致原有特定状态消失（如重新实现系统函数）。

第二类方法更加新，更加通用。这类方法通过监控加壳应用的运行，捕获加壳应用在运行过程中释放的真实代码。我们将这类方法称为基于运行时监控的脱壳。由于加壳服务不会影响应用的正常运行，因此在运行的过程中，应用的函数会被解密和执行。DroidUnpack和PackerGrind都属于这类方法，均取得了不错的效果。然而，这类方法存在一个难以解决的问题：动态运行的代码覆盖率。而这是一个已知的困难问题。

因此，已有脱壳方法都存在着不同的缺陷。除此以外，以往的脱壳方法都针对于内存加密壳，即dex方法加密后会被还原。而随着加壳软件的发展，已经出现一类新的加壳方案—VMP，将原有方法或自定义解释器的字节码，加密后的dex方法不再还原。

本文的目标是设计一种更加通用的脱壳方法，解决已有脱壳方法的不足。为此，我们设计并实现了Rupk系统。Rupk系统依旧采用了运行时监控的原理，在应用函数运行的过程中对函数进行监控，收集函数的代码，重组还原成dex文件。但Rupk通过创造性的强制反射调用方式，可到达近乎100%的方法覆盖率，解决了传统运行时监控脱壳方案的不足。为了更好的介绍Rupk系统，我们提出并回答了以下问题：

**RQ1: 什么是强制反射调用？为何能到达近乎100%的方法覆盖率？**

强制反射调用是，构造方法的参数和上下文，利用Java反射机制，强行调用一个Java方法。在分析Android应用的过程中，我们有以下发现：1）反射是Java的原生机制，当获取一个类的信息之后，就可以得到类的所有方法，并且进行调用；2）反射在正常的Android应用也被大量使用。我们假设加壳服务并不会影响应用的正常反射机制，因此，通过反射调用应用的所有方法，就可以让所有方法运行，解决代码覆盖率问题。

然而，分析一个方法的参数和上下文是一件困难的事情，让所有方法都正常执行并不现实。但方法是否正常执行并不会对Rupk的结果有影响。Rupk的目标是以方法为粒度进行脱壳，只要方法开始执行，就能过获取方法的原始代码；即使应用崩溃，当前方法代码已被提取，重启应用继续强制调用下一个方法就能继续脱壳。只要所有方法都被强制反射调用，就可以达到近乎100%的方法覆盖率。可以看到，强制反射调用非常适合脱壳这个场景。

**RQ2: 强制反射调用过程中，如何避免频繁崩溃？**

为了降低崩溃次数，我们设计了一套错误处理方案。虽然崩溃并不会影响脱壳的效果，但频繁崩溃将导致降低脱壳的效率。函数的崩溃有两种原因，一种是在Java层面发生的异常，一种是在native层面发生的异常。对于Java层面发生的异常，Rupk系统利用Java原生的异常捕获机制，捕获Java异常，避免应用崩溃，可以继续强制反射调用后续方法。对于native层面的异常，Rupk虽然无法避免应用崩溃，但Rupk在运行过程中，及时并完整记录的状态，在系统重启后，避免重复分析已分析过的函数，降低崩溃次数。在实验中，仅有XXX%的方法会发生崩溃，证明了Rupk的错误处理机制非常有效，提高了脱壳的性能。

**RQ3: Rupk的通用性和有效性如何？**

我们在XXX个覆盖20XX-20XX时间上的加壳样本上进行实验，XXXX个方法中，XXX%方法能够被还原代码。这些样本覆盖了AAA、BBB、CCC等主流加壳服务。实验证明了Rupk的有效性。

在Case Study中，我们还展示了一类特殊的样本，加密函数在函数执行前解密，函数执行后重新加密。Rupk也能正确处理这类函数，展现了Rupk的优点。

对于VMP壳，虽然Rupk并不能对抗VMP，但实验表明，仅不到XXX%的方法可能采用了VMP加密，且XXX%的方法是能被正确还原代码的。因此，可以说明，即使VMP经过多年发展，内存加密也仍是主要的加壳方式。而Rupk对于内存加密有着优异脱壳效果，因此，对于最新的加壳服务，Rupk仍是通用的解决方案。

我们的贡献如下：

- 我们首次提出了基于强制反射调用的通用脱壳方案并实现了Rupk系统。Rupk系统克服了现有脱壳方案的不足。Rupk监控函数的执行，在函数运行时搜集函数代码，以方法为粒度重组原始dex文件。通过强制反射调用，Rupk能实现近乎100%的方法覆盖率。此外，Rupk设计了错误处理机制，降低了强制反射调用引发的崩溃次数，提升了脱壳的效率。
- 在XXX个包含AAA、BBB等加壳服务，覆盖20XX-20XX时间段的加壳样本上对Rupk系统进行测试，实现表明，Rupk可还原XXX%的方法代码，具有优异的脱壳效果。Rupk还能处理以往脱壳系统无法处理的函数运行前解密、运行后加密的加壳方法。
- 本文的实验揭露了，虽然VMP加密已经出现，但内存加密依旧是主要的加壳方案，VMP仅是辅助。而Rupk是内存加密的通用脱壳方案，也是当前加壳服务的通用脱壳方案。

# BackGround

**安卓Java字节码**

**Java反射**

# System overview

**本文的目标是设计一种更加通用的脱壳方法，解决已有脱壳方法的不足。为此，我们设计并实现了Rupk系统。Rupk系统依旧采用了运行时监控的原理，在应用函数运行的过程中对函数进行监控，收集函数的代码，重组还原成dex文件。但Rupk通过创造性的强制反射调用方式，可到达近乎100%的方法覆盖率，解决了传统运行时监控脱壳方案的不足。为了更好的介绍Rupk系统，我们提出并回答了以下问题：**

传统的基于运行时监控的脱壳无法保证方法覆盖率。为了解决这个问题，Rupk通过创新性的强制反射调用方式，强制反射调用类中的每一个方法，在方法运行时对函数进行监控，收集函数的代码，重组还原成dex文件。可达到近乎100%的方法率。

Rupk系统的结构主要由以下5个部分组成：
1）Dex文件和classloader的获取
2）类的初始化与类代码的强制反射调用
3）监控应用函数的运行，收集相关信息
4）重组dex文件
5）强制反射调用中的崩溃避免与崩溃处理

下面，我们将分别介绍这5个部分。

A. Dex文件和classloader的获取

为了获得应用定义的所有类代码，我们首先需要获得应用打开的dex文件以及应用加载dex文件时所用的classloader。为此，Rupk系统修改了应用启动的代码，在应用启动时，如果应用的包名是目标应用的包名，则启动一个新的线程。同时，Rupk系统导出了dalvik虚拟机的全局变量gDvm，新线程可从gDvm中获得应用所打开的Dex文件和对应的classloader。

B. 类的初始化与类代码的强制反射调用

获得Dex文件和对应的classloader后，Rupk可使用dvmDefineClass得到Dex文件中定义的每一个类，然后使用dvmInitClass对类进行初始化。而后，为了进行强制反射调用，Rupk将native层初始化好的类传递给Java层。使用getDeclaredConstructors和getDeclaredMethods获得类定义的函数。同时修改Java层的newInstance函数，新建一个内容为空的类实例供函数强制反射调用时使用。因为加壳服务并不会影响应用的正常反射机制，因此，强制反射调用的参数不会影响函数的正常执行。Rupk系统修改了强制反射调用的调用链，使得调用时无需提供参数。

C.监控应用函数的运行，收集相关信息

强制反射调用函数时，分为两种情况。
若调用的函数是Native函数，此时应该检查该Native函数的指针，如果其指针指向加壳服务的so文件，则说明该Native函数可能经过了“处理”，有可能是vmp函数。对于每一个Native函数，无论其是静态注册还是动态注册，最终都会由dvmCallJniMethod进行处理，Rupk修改了dvmCallJniMethod，在函数执行前，读取/proc/pid_of_process/maps文件，获得与Native方法的指针指向地址相关的信息。记录下来供研究人员分析。
若调用的函数是Java函数，Rupk系统会用修改后的dvmInterpretPortable解释器解释执行，在解释执行的过程中，Rupk系统在三个关键语句内进行插桩，以应对函数自修改的情况，在函数发生崩溃前记录下函数的代码，供重组dex文件时使用。

D.重组dex文件

待所有函数代码都被收集后，Rupk结合Dex文件中的信息，拼接重组成新的dex文件。

E.强制反射调用中的崩溃避免与崩溃处理

在绝大部分强制反射调用函数代码的情况下，由于没有给出合适的参数和上下文，函数都会崩溃。而频繁的崩溃和重启将影响到Rupk的脱壳速度。因此，Rupk设计了一套错误处理方法尽可能的避免应用崩溃。在Java层，Rupk使用try-catch包裹住强制反射调用函数的部分，当崩溃是由解释器解释Java字节码产生时，此崩溃能够被try-catch正常捕获。对于无法捕获的崩溃，Rupk会在强制反射调用函数代码前，记录下此函数代码所在的Dex文件，所在的类，以及具体的函数编号，并保存在本地。当崩溃以后再重启Rupk时，其首先找到本地记录的状态，避免重复分析已分析过的函数。

# Design and implementation

我们在Android 4.4.4_r1上实现了Rupk系统，图xx展示了Rupk系统的架构图。Rupk系统的结构主要由以下5个部分组成：
1）Dex文件和classloader的获取
2）类的初始化与类代码的强制反射调用
3）监控应用函数的运行，收集相关信息
4）重组dex文件
5）强制反射调用中的崩溃避免与崩溃处理
下面我们将详细的介绍这五个部分的实现。

A.Dex文件和classloader的获取

Dex文件和classloader的获取包含以下两个部分：

- 注⼊目标应用
  为了获取目标应用打开的Dex文件和相应的classloader。Rupk需要在目标应用内打开一个新的线程。当应用启动时，其都会经过ActivityThread类中的handleBindApplication函数，Rupk在此处添加一段代码，如果此时data.info.getPackageName()与保存在本地文件中需要脱壳应用的包名相同，则说明当前的应用就是目标应用，此时会新建一个线程，并在线程中完成后续的步骤。

- Dex文件和对应classloader的获取
  dalvik虚拟机加载dex文件时，会使用Dalvik_dalvik_system_DexFile_openDexFileNative函数，该函数尝试把参数的文件当成后缀为.dex的文件打开，如果打开失败的话，则把它当做一个包含有classes.dex文件的Zip文件进行打开。打开以后，存储到pDexOrJar中，并用addToDexFileTable最终添加到gDvm中的userDexFile中。一般情况下，同一个Dex文件中的所有类都由同一个classloader进行加载，已加载的类通过dvmAddClassToHash被添加到gDvm.loadedClasses中。为了获取Dex文件和对应的classloader，Rupk修改了Android源代码，将gDvm开放出来，线程会访问gDvm,获得目标应用打开的Dex文件。对于Dex文件，访问gDvm获得已加载的所有类，如果某个类的pDvmDex等于此时Dex文件的pDvmDex，则说明此类属于此时的Dex文件，Rupk将使用加载该类的classloader完成后续的类加载。

B.类的初始化与类代码的强制反射调用

- 类的初始化
  从Dex文件中，我们可以获得所有的类标识符(descriptor),并使用dvmDefineClass将这些类都定义出来。在同一个类中，类初始化函数\<clinit>会先于其他函数被调用。加壳服务可以在\<clinit>中添加代码完成动态代码修改。因此，Rupk会使用dvmIsClassInitialized检查该类是否已被初始化，如果已被初始化，则其中的\<clinit>函数已被执行。若无，则使用dvmInitClass对类进行强制初始化。dvmInitClass会执行类中的初始化函数\<clinit>函数。

  (有的加壳服务会添加些无用的类，然后在类的\<clinit>函数加入exit，影响脱壳)

- 获得类定义的方法
  为了使用Java层的反射机制，我们需要将c层定义好的类传递给Java层。这可以使用RETURN_PTR(clazz)实现，其中clazz是由dvmDefineClass定义出的类。获得Java层的类以后，Rupk使用getDeclaredConstructors和getDeclaredMethods获得该类定义的所有方法（


应⽤层：

- 获取dex文件 (dex locating)
- 类加载 (class loading)
- 强制反射调用方法 (method invoking)
- dex⽂件的重组 (dex recovring)

监控执行层

- Native⽅法的监控 (native method monitor)
- Java方法的监控 (java method monitor)

崩溃重启层

- 监控是否发⽣崩溃 (crash monitor)

## C.Design and implementation

分别详细的介绍四个层次的具体实现

系统启动层：

- **透明注⼊** (transparent injection）为了避开反调试， Rupk系统修改了java框架，使得所有应⽤启动时都会经过⼀段额外的代码，为注入做准备
- **⽬标应用识别** (target identification) 这段额外的代码检查包名，如果与本地固定位置储存的包名相同，说明是我们⽬标加壳应⽤
- **提取器的加载** (extractior loading) 然后启动保存在本地固定位置的so资源⽂件，这个资源⽂件是提取器，是应用层的⼊⼝

应用层：

- **获取dex文件** (dex locating) ⾸先从开放出的gdvm.loadedClasses中获取dex文件，然后获取缓存的类加载器
- **类加载** (class loading) 遍历dex⽂件中的每一个类，然后使用类加载器进行加载并初始化
- **强制反射调⽤⽅法** (method invoking) 然后强制反射调⽤类中定义的所有方法，⽅法的执⾏受到监控执⾏层的监控
- **dex文件的重组** (dex recovring) 监控执行层可以得到相应的字节码，结合dex⽂件中的string, proto_id等信息，重组出dex⽂文件

监控执行层：

- **Native⽅法的监控** (native method monitor) 如果当前所执行的是native方法，检查proc/id/maps,如果指向壳so文件，记录下来，给研究⼈员分析，可能是vmp方法。继续执行native方法，由于native方法可能是个自解密，最后会跳转到原始的java方法，因此执行native方法是有必要的

- **Java方法的监控** (java method monitor) 如果当前所执⾏的是java⽅法，则记录下java⽅法执⾏中的函数调用链，记录下其中的Java函数的字节码，并保存到本地，供重组dex⽂件时使用。

崩溃重启层

- **监控是否发生崩溃** (crash monitor) Java层的崩溃可以通过try catch捕获，native层的崩溃无法捕获，故每次强制反射调⽤方法时，记录下类号与⽅法号，当应⽤崩溃时，外部的脚本⾃动重启该加壳应用，重新进行脱壳，脱壳时，从当前类号的下一个⽅法号处继续脱壳。

# Evaluation

在这节中，我们将要回答以前所提出的三个问题

**问题⼀：内存脱壳还有效吗？如果⽆效，是什么原因所导致的**

**问题二：监控式脱壳系统的代码覆盖率如何？这类脱壳系统能还原出原始应用的所有代码吗？**

**问题三：是否存在一种通用的脱壳⽅法？**

我们将会使⽤样本集进⾏相应的实验，回答这三个问题。

A. 样本集

- 随机收集的样本(恶意样本) 2015~2019
- 已知源码的样本，然后送到⽬前的免费加壳服务上加壳 2019

B. 问题一：内存脱壳还有效吗？如果⽆效，是什么原因所导致的

由于Dexhunter与Appspear都是开源的，因此可以通过实验得出结论。 初步结论是，都⽆效，这部分的实验比较好做

C. 问题⼆：监控式脱壳系统的代码覆盖率如何？这类脱壳系统能还原出原始应用的所有代码吗？

PackerGrind提到的自身的弱点：

> PackerGrind can unpack apps protected by all mechanisms except the Re-implement Method.

Re-implement Method 即是百度的onCreate 

> PackerGrind can only recover the Dex data after the methods
for releasing the real code are invoked.

因此，只要找到样本，该样本存在加密方法，这个方法在应用简单运行时不会被释放即可。

DroidUnpack提到的自身的弱点：

> DroidUnpack certainly suffers from limited cover coverage as it can only dump the code that executes.  

这和PackerGrind有着微妙的不同，PackerGrind无法脱的样本DroidUnpack肯定没法脱，除此之外，如果一个应用在运行的时候不会运行到所有的方法，哪怕该方法没有被加密，DroidUnpack也脱不下来。

> And since it is built on top of whole-system emulation, packers that enforce anti-emulation techniques will inevitably break the analysis.

反模拟器的样本应该挺好找的。

D. 问题三：是否存在⼀种通用的脱壳方法？

有，我们提出了Rupk系统，下面就是要证明Rupk系统能够正确的脱壳。 使⽤两个样本集对Rupk系统进⾏全面的测试。看Rupk系统还原出的Java方法的⽐例。结论，Rupk系统的脱壳准确率⾮常⾼之类的。

E. ⽬前的加壳保护技术

这⾥介绍2019年各家加壳⼚商的加壳技术 : 内存加壳结合vmp。可以做case study。

# Limitations and future work

介绍Rupk系统的局限性，耗时很长，只⽀持Android 4.4的dvm虚拟机。native代码的执⾏可以做更多的监控，强制反射调用时参数的填充可以更加的好，⽆法解决vmp壳。

# Related Work

介绍相关⼯作

# Conclusion

与Introduction中的贡献对照着写