# Abstract

近年来，Android加壳服务被广泛使用。为了分析被加壳的应用，研究者们提出了一系列脱壳方法。这些脱壳方法可分为两类：

第一类脱壳方法在应用运行到达一定状态后，转储内存，重新拼接得到脱壳后的dex。这类方法假设在某一状态，所有加密代码都被解密释放到内存。但如今，加壳服务已经实现运行阶段多层次解密，这类脱壳方法无法保证存在这样可以脱壳的特定状态并能成功触发该状态。

第二类脱壳方法通过监控加壳应用运行过程，在加壳服务释放真实代码或执行函数时，收集函数代码重组得到dex。但这类脱壳方法无法保证所有被加壳服务加密的代码在运行过程中都被释放或执行。因此脱壳得到的dex文件可能并不完整

为了解决目前脱壳方法中存在的问题，我们提出了一种全新的通用脱壳方法，并实现了Rupk系统。Rupk假设Android函数运行过程中，函数处于解密状态。为了让所有函数均被执行，Rupk创造性地强制执行所有函数，提高代码覆盖率。Rupk通过构建参数，反射调用目标函数，实现对目标函数的强制调用。在函数触发异常前，Rupk提取函数被还原后的代码，用于重组dex。同时，Rupk利用异常捕获机制，将崩溃次数降低到XXX%，并通过状态记录，在崩溃后重启应用，强制调用后续函数，继续脱壳进程。

在XXX个覆盖20XX-20XX时间上的加壳样本上进行实验，XXXX个方法中，XXX%方法能够被还原代码，证明了Rupk的有效性。进一步，我们实验还表明，Rupk还能处理以往脱壳系统无法处理的函数运行前解密、运行后加密的加壳方法。

# Introduction 

Android是市场上份额最高的移动操作系统，根据IDC的统计，2018年android手机的全球出货量在总出货量中的占比为85.1%，远超其他系统手机。为了保护Android应用免受逆向和篡改，出现了一系列加壳服务。虽然这些加壳服务保护了应用，但恶意软件也在滥用加壳服务，以躲避安全检测和研究人员的分析。除此以外，加壳后的应用也难以被分析漏洞、隐私泄漏等安全问题。

为了解决上述问题，研究者们提出了一系列脱壳方法，还原被加壳的应用。这些方法可大致分为两类：

第一类方法假设加壳应用运行的过程中存在一个合适的状态，dex所有加密代码都被解密释放到内存中，在此状态处转储内存，重新拼接可以得到脱壳后的dex。我们将这类方法称为基于合适状态(Right timing)的脱壳。这类方法出现较早，2015年的AppSpear和DexHunter。这类方法刚出现时都取得了不错的脱壳效果，但如今，加壳服务不断发展变化，并已经实现运行阶段多层次解密。这类脱壳方法无法保证:1)存在这样可以脱壳的特定状态；2）能成功触发该状态；3）加壳软件在更新的版本中不会导致原有特定状态消失（如重新实现系统函数）。

第二类方法更加新，更加通用。这类方法通过监控加壳应用的运行，捕获加壳应用在运行过程中释放的真实代码。我们将这类方法称为基于运行时监控的脱壳。由于加壳服务不会影响应用的正常运行，因此在运行的过程中，应用的函数会被解密和执行。DroidUnpack和PackerGrind都属于这类方法，均取得了不错的效果。然而，这类方法存在一个难以解决的问题：动态运行的代码覆盖率。而这是一个已知的困难问题。

因此，已有脱壳方法都存在着不同的缺陷。除此以外，以往的脱壳方法都针对于内存加密壳，即dex方法加密后会被还原。而随着加壳软件的发展，已经出现一类新的加壳方案—VMP，将原有方法或自定义解释器的字节码，加密后的dex方法不再还原。

本文的目标是设计一种更加通用的脱壳方法，解决已有脱壳方法的不足。为此，我们设计并实现了Rupk系统。Rupk系统依旧采用了运行时监控的原理，在应用函数运行的过程中对函数进行监控，收集函数的代码，重组还原成dex文件。但Rupk通过创造性的强制反射调用方式，可到达近乎100%的方法覆盖率，解决了传统运行时监控脱壳方案的不足。为了更好的介绍Rupk系统，我们提出并回答了以下问题：

**RQ1: 什么是强制反射调用？为何能到达近乎100%的方法覆盖率？**

强制反射调用是，构造方法的参数和上下文，利用Java反射机制，强行调用一个Java方法。在分析Android应用的过程中，我们有以下发现：1）反射是Java的原生机制，当获取一个类的信息之后，就可以得到类的所有方法，并且进行调用；2）反射在正常的Android应用也被大量使用。我们假设加壳服务并不会影响应用的正常反射机制，因此，通过反射调用应用的所有方法，就可以让所有方法运行，解决代码覆盖率问题。

然而，分析一个方法的参数和上下文是一件困难的事情，让所有方法都正常执行并不现实。但方法是否正常执行并不会对Rupk的结果有影响。Rupk的目标是以方法为粒度进行脱壳，只要方法开始执行，就能过获取方法的原始代码；即使应用崩溃，当前方法代码已被提取，重启应用继续强制调用下一个方法就能继续脱壳。只要所有方法都被强制反射调用，就可以达到近乎100%的方法覆盖率。可以看到，强制反射调用非常适合脱壳这个场景。

**RQ2: 强制反射调用过程中，如何避免频繁崩溃？**

为了降低崩溃次数，我们设计了一套错误处理方案。虽然崩溃并不会影响脱壳的效果，但频繁崩溃将导致降低脱壳的效率。函数的崩溃有两种原因，一种是在Java层面发生的异常，一种是在native层面发生的异常。对于Java层面发生的异常，Rupk系统利用Java原生的异常捕获机制，捕获Java异常，避免应用崩溃，可以继续强制反射调用后续方法。对于native层面的异常，Rupk虽然无法避免应用崩溃，但Rupk在运行过程中，及时并完整记录的状态，在系统重启后，避免重复分析已分析过的函数，降低崩溃次数。在实验中，仅有XXX%的方法会发生崩溃，证明了Rupk的错误处理机制非常有效，提高了脱壳的性能。

**RQ3: Rupk的通用性和有效性如何？**

我们在XXX个覆盖20XX-20XX时间上的加壳样本上进行实验，XXXX个方法中，XXX%方法能够被还原代码。这些样本覆盖了AAA、BBB、CCC等主流加壳服务。实验证明了Rupk的有效性。

在Case Study中，我们还展示了一类特殊的样本，加密函数在函数执行前解密，函数执行后重新加密。Rupk也能正确处理这类函数，展现了Rupk的优点。

对于VMP壳，虽然Rupk并不能对抗VMP，但实验表明，仅不到XXX%的方法可能采用了VMP加密，且XXX%的方法是能被正确还原代码的。因此，可以说明，即使VMP经过多年发展，内存加密也仍是主要的加壳方式。而Rupk对于内存加密有着优异脱壳效果，因此，对于最新的加壳服务，Rupk仍是通用的解决方案。

我们的贡献如下：

- 我们首次提出了基于强制反射调用的通用脱壳方案并实现了Rupk系统。Rupk系统克服了现有脱壳方案的不足。Rupk监控函数的执行，在函数运行时搜集函数代码，以方法为粒度重组原始dex文件。通过强制反射调用，Rupk能实现近乎100%的方法覆盖率。此外，Rupk设计了错误处理机制，降低了强制反射调用引发的崩溃次数，提升了脱壳的效率。
- 在XXX个包含AAA、BBB等加壳服务，覆盖20XX-20XX时间段的加壳样本上对Rupk系统进行测试，实现表明，Rupk可还原XXX%的方法代码，具有优异的脱壳效果。Rupk还能处理以往脱壳系统无法处理的函数运行前解密、运行后加密的加壳方法。
- 本文的实验揭露了，虽然VMP加密已经出现，但内存加密依旧是主要的加壳方案，VMP仅是辅助。而Rupk是内存加密的通用脱壳方案，也是当前加壳服务的通用脱壳方案。

# BackGround

**安卓Java字节码**

**Java反射**

# System overview

传统的基于运行时监控的脱壳无法保证方法覆盖率。为了解决这个问题，Rupk通过创新性的强制反射调用方式，强制反射调用类中的每一个方法，在方法运行时对函数进行监控，收集函数的代码，重组还原成dex文件。可达到近乎100%的方法覆盖率。

Rupk系统的结构主要由以下5个部分组成：
1）Dex文件和classloader的获取
2）类的初始化与类代码的强制反射调用
3）监控应用函数的运行，收集相关信息
4）重组dex文件
5）强制反射调用中的崩溃避免与崩溃处理

下面，我们将分别介绍这5个部分。

A. Dex文件和classloader的获取

为了获得应用定义的所有类代码，我们首先要获得应用打开的dex文件以及应用加载dex文件时所用的classloader。为此，Rupk系统修改了应用启动的代码，在应用启动时，如果应用的包名是目标应用的包名，则启动一个新的线程。同时，Rupk系统导出了dalvik虚拟机的全局变量gDvm，新线程可从gDvm中获得应用所打开的Dex文件和对应的classloader。

B. 类的初始化与类函数的强制反射调用

获得Dex文件和对应的classloader后，Rupk可使用dvmDefineClass得到Dex文件中定义的每一个类，然后使用dvmInitClass对类进行初始化。而后，Rupk将强制反射调用类中定义的每一个函数。为了在Java层进行强制反射调用，Rupk将c层初始化好的类传递给Java层。使用getDeclaredConstructors和getDeclaredMethods获得类定义的所有函数。Rupk假设加壳服务不会影响应用的正常反射机制，因此，强制反射调用的参数不会影响函数在运行过程中的解密。Rupk修改了强制反射调用的部分代码，使得调用时无需提供参数。

C.监控应用函数的运行，收集相关信息

强制反射调用函数时，分为两种情况。
若调用的函数是Native函数，此时应该检查该Native函数的指针，如果其指针指向加壳服务的so文件，则说明该Native函数可能经过了“处理”，有可能是vmp函数。对于每一个Native函数，无论其是隐式注册还是显式注册，最终都会由dvmCallJniMethod进行处理，Rupk修改了dvmCallJniMethod，在函数执行前，读取/proc/pid_of_process/maps文件，获得与Native方法的指针指向地址相关的信息。记录下来供研究人员分析。
若调用的函数是Java函数，Rupk系统会用修改后的dvmInterpretPortable解释器解释执行，在解释执行的过程中，Rupk系统在三个关键opcode的解释逻辑内进行插桩，记录下函数的字节码，以应对函数自修改的情况，供重组dex文件时使用。

D.重组dex文件

待Java函数代码都被记录后，Rupk逐段转储已打开Dex文件中的字符串信息、类型信息、原型信息、字段信息以及方法信息，再结合被记录的Java函数字节码，重组成新的dex文件。

E.强制反射调用中的崩溃避免与崩溃处理

在绝大部分强制反射调用函数的情况下，由于没有给出合适的参数和上下文，函数都会崩溃。而频繁的崩溃和重启将影响到Rupk的脱壳速度。因此，Rupk设计了一套崩溃处理方法尽可能的避免应用崩溃。在Java层，Rupk使用try-catch包裹住强制反射调用函数的部分，当崩溃是由解释器解释Java字节码产生时，此崩溃能够被try-catch正常捕获。对于无法捕获的崩溃，Rupk会在强制反射调用函数代码前，记录下此函数代码所在的Dex文件，所在的类，以及具体的函数编号，并保存在本地。当崩溃后再重启Rupk时，其首先找到本地记录的状态，避免重复调用已调用过的函数。

# Design and implementation

我们在Android 4.4.4_r1上实现了Rupk系统，图xx展示了Rupk系统的架构图。Rupk系统的结构主要由以下5个部分组成：
1）Dex文件和classloader的获取
2）类的初始化与类代码的强制反射调用
3）监控应用函数的运行，收集相关信息
4）重组dex文件
5）强制反射调用中的崩溃避免与崩溃处理
下面我们将详细的介绍这五个部分的实现。

A.Dex文件和classloader的获取

Dex文件和classloader的获取包含以下两个部分：

- 注⼊目标应用
  为了获取目标应用打开的Dex文件和相应的classloader。Rupk需要在目标应用内打开一个新的线程。当应用启动时，其都会经过ActivityThread类中的handleBindApplication函数，Rupk在此处添加一段代码，如果此时data.info.getPackageName与保存在本地文件中需要脱壳应用的包名相同，则说明当前的应用就是目标应用，此时会新建一个线程，并在线程中完成后续的步骤。

- Dex文件和对应classloader的获取
  dalvik虚拟机加载dex文件时，会使用Dalvik_dalvik_system_DexFile_openDexFileNative函数，该函数尝试把参数的文件当成后缀为.dex的文件打开，如果打开失败的话，则把它当做一个包含classes.dex文件的Zip文件打开。打开dex文件以后，将其存储到pDexOrJar中，并用addToDexFileTable最终添加到gDvm中的userDexFile中。一般情况下，同一个Dex文件中的所有类都由同一个classloader进行加载，已加载的类通过dvmAddClassToHash被添加到gDvm.loadedClasses中。为了获取Dex文件和对应的classloader，Rupk修改了Android源代码，将gDvm开放出来，线程会访问gDvm,获得目标应用打开的Dex文件。对于Dex文件，访问gDvm获得已加载的所有类，如果某个类的pDvmDex等于此时Dex文件的pDvmDex，则说明此类属于此时的Dex文件，Rupk将使用加载该类的classloader完成此dex文件中后续的类加载。

B.类的初始化与类代码的强制反射调用

- 类的初始化
  从Dex文件中，我们可以获得所有的类标识符(descriptor),并使用dvmDefineClass将这些类都定义出来。在同一个类中，类初始化函数\<clinit>会先于其他函数被调用。加壳服务可以在\<clinit>中添加代码完成动态代码修改。为了保证Rupk能得到真实的代码，Rupk使用dvmIsClassInitialized检查类是否已被初始化，如果已被初始化，则其中的\<clinit>函数已被执行。若无，则使用dvmInitClass对类进行强制初始化。dvmInitClass会执行类中的初始化函数\<clinit>函数。

  (有的加壳服务会添加些无用的类，然后在类的\<clinit>函数加入exit，影响脱壳)

- 类的传递与类定义函数的获取
  为了使用Java层的反射机制，我们需要将c层定义好的类传递给Java层。这可以使用RETURN_PTR(clazz)实现，其中clazz是由dvmDefineClass定义出的类。获得Java层的类以后，Rupk使用getDeclaredConstructors和getDeclaredMethods获得该类定义的所有函数，这些函数包括类的构造函数和普通函数。

- 类函数的强制反射调用
  类的函数可分为两大类：构造函数和普通函数。Java内可通过构造器(Constructor)的newInstance来执行构造函数，通过方法(Method)的invoke来执行普通函数。
  
  构造器(Constructor)使用newInstance生成一个新的对象：newInstance ——> constructNative ——> Dalvik_java_lang_reflect_Constructor_constructNative, 在Dalvik_java_lang_reflect_Constructor_constructNative中，首先为当前类分配空间，新建一个对象，然后在这个类上使用dvmInvokeMethod运行构造函数。
  
  方法(Method)使用invoke进行调用：invoke ——> invokeNative ——>  Dalvik_java_lang_reflect_Method_invokeNative，在Dalvik_java_lang_reflect_Method_invokeNative中，最终使用dvmInvokeMethod运行普通函数。

  我们假设加壳服务不会影响应用的正常反射机制，因此，通过强制反射调用应用的所有方法，在方法执行时收集方法的原始代码，便可解决应用脱壳以及代码覆盖率的问题。在上述的假设中，方法执行时的参数不会影响加壳服务的解密过程，不正确的参数只会影响方法正常执行。但方法是否正常执行并不会对Rupk的脱壳结果有影响。Rupk的目标是以方法为粒度进行脱壳，只要方法开始执行，就能获取方法的原始代码；即使应用崩溃，当前方法代码已被提取。
  
  因此Rupk对Android源代码进行了修改，在强制反射调用时，使用了新的函数调用链，在原本的函数名称前都加了ex，如原本构造器生成一个新的对象的调用链为：newInstance ——> constructNative ——> Dalvik_java_lang_reflect_Constructor_constructNative ——> dvmInvokeMethod, 现在变成了 exnewInstance ——> exconstructNative ——> exDalvik_java_lang_reflect_Constructor_constructNative ——> exdvmInvokeMethod。且修改了调用链的实现，使得强制调用时无需提供参数。对于普通函数的invoke调用链同理。

C. 监控应用函数的运行，收集相关信息
  强制反射调用类函数时，构造函数和普通函数最终都会使用exdvmInvokeMethod执行代码。在exdvmInvokeMethod中，Java方法和Native方法有着不同的执行方式，下面我们将介绍Rupk对这两种方法的监控和代码收集方式。

- Java方法
  在exdvmInvokeMethod内，如果当前的执行方法为Java方法，则使用exdvmInterpret来准备方法的执行。Dalvik虚拟机支持三种执行模式：portable、fast和jit，它们分别使用kExecutionModeInterpPortable、kExecutionModeInterpFast和kExecutionModeJit三个常量来表示。Dalvik虚拟机在启动的时候，会通过解析命令行参数获得所要执行的模式，并且记录在全局变量gDvm所指向的一个DvmGlobals结构体的成员变量executionMode中。

  根据executionMode的值，dalvik虚拟机可以使用函数dvmMterpStd或者函数dvmInterpretPortable来作为Java代码的执行函数。dvmMterpStd由汇编实现，dvmInterpretPortable由c++实现，Rupk以dvmInterpretPortable作为被监控Java函数的唯一执行函数，当进入dvmInterpretPortable时，解释器会一句句的对Java方法的insns进行解释执行。Rupk会在Java字节码解释执行时，记录下当前method的insns，用来重组dex文件。

  由于Java方法字节码的opcode非常的多，如果在每一种opcode的处理位置，都记录下当前method的insns的话，会减慢Java方法的运行效率，减慢Rupk的脱壳速度。Rupk只在returnFromMethod,exceptionThrown和invokeMethod处记录Java方法的insns，这是因为Java字节码在解释执行时，没有办法对自身进行修改(method->insns)，如果加壳服务添加了代码，使得Java方法在执行时发生了动态的修改，这一定是因为Java方法在执行过程中，调用了其他的Native方法。因此Rupk在invokeMethod前记录一次Java方法的insns。当方法返回时，该方法的字节码可能已经发生了修改，故Rupk在returnFromMethod处记录一次Java方法的insns。Java方法在调用其他Native方法使得自身被修改后，可能由于异常的产生无法正确的返回，故Rupk在exceptionThrown处记录一次Java方法的insns。被记录的Java方法字节码会被保存到本地，供重组dex文件时使用。

- Native方法
  在Android中，既可以隐式注册Native方法，也可以显式注册Native方法，下面我们分析这两种不同的注册方法，并介绍Rupk对Native方法运行的监控方式。Rupk会记录与Native方法指针相关的信息。由于dex文件中不包含native代码，所以Rupk不会对native代码进行收集。
  
  隐式注册Native方法：当Rupk使用dvmDefineClass从dex文件加载类时，经过一系列的调用，最终使用loadMethodFromDex构建该类的所有方法，若此时的方法属性为Native，则loadMethodFromDex将方法的nativeFunc设置成dvmResolveNativeMethod，在exdvmInvokeMethod内，最终使用nativeFunc来执行Native方法。隐式注册的Native方法一开始使用dvmResolveNativeMethod运行，其检查这个函数是不是系统内部定义的Native函数，若不是，则使用lookupSharedLibMethod扫描所有加载了的DLLs，希望能够通过相应的名字映射规则从加载了的DLLs中找到对应的Native函数定义。如果找到了，则用dvmUseJNIBridge进行相应的注册。
  
  dvmDefineClass->findClassNoInit->loadClassfromDex->loadClassfromDex0->loadMethodFromDex

  显式注册Native方法：应用可以使用JNIEnv.RegisterNatives来显式的注册Native方法。RegisterNatives使用dvmRegisterJNIMethod对每一个Native方法进行注册，并最终用dvmUseJNIBridge完成注册。

  可以看到，隐式注册和显式注册最终都会使用dvmUseJNIBridge完成Native方法的注册，dvmUseJNIBridge Point "method->nativeFunc" at the JNI bridge, and overload "method->insns" to point at the actual function. 根据gDvmJni.useCheckJni的值，JNI bridge可以选择dvmCheckCallJNIMethod或者dvmCallJNIMethod，Rupk修改源码，将dvmCallJNIMethod作为Native函数的唯一执行入口。当Native方法执行时，method——>insns保存着Native方法的真实函数指针，正常情况下，该指针指向的是应用自身的so，如果加壳服务将当前的方法重写成vmp方法，则此时指针指向的是加壳服务的so文件。因此记录下Native方法的函数指针能够帮助研究人员分析加壳应用。Rupk在Native方法真正运行前(before dvmPlatformInvoke)，通过读取/proc/pid_of_process/maps文件，获得与Native方法的指针指向地址相关的信息，并记录下来。

D.重组dex文件
  当应用中所有类的方法都被强制反射调用后，Rupk就可以使用记录的Java字节码以及应用打开的dex文件中的信息重组Dex文件了。Dex文件由多项不同类型数据结构组成，且通过加载基址加上数据偏移的方式来计算数据存放位置，因此，通常需要根据偏移值进行多次索引，才能获取相应数据内容。例如，存放于DexHeader的stringIdsOff代表了字符串类型数据结构DexStringId的起始偏移，通过DexStringId中stringDataOff成员的值，我们可以获得MUTF-8编码的实际字符串内容。除字符串信息外，dex文件还包含了类型信息、原型信息、字段信息、方法信息、类信息以及依赖信息等部分。未加壳情况下，这些信息在内存中的排布是连续的，可以通过整体转储内存得到，但加壳服务可以打乱这些信息在内存中的排布形式。因此Rupk在知道打开的dex文件内存基址后，根据上述索引方式，解析字符串信息、类型信息、原型信息、字段信息、方法信息所在内存地址，并获取内容，保存到新的Dex文件中，对于已打开Dex文件中的类信息，类信息中保存的类方法数据不一定处于解密状态，但Rupk已经通过强制反射调用类方法，监控应用函数的运行，将解密后的类方法数据保存到本地。Rupk使用保存在本地的类方法数据重组新的dex文件。

E.强制反射调用中的崩溃避免与崩溃处理
  在强制反射调用方法时，由于没有提供方法参数和正确的上下文，大多数方法无法正常执行，这会引发崩溃，使得Rupk的脱壳操作终止。频繁的崩溃和重启将影响到Rupk的脱壳速度。因此，Rupk设计了一套崩溃处理方法尽可能的避免应用崩溃。下面将介绍Rupk如何在强制反射调用中避免崩溃以及崩溃后的处理。

- 强制反射调用中的崩溃避免
  在Java中，try-catch 语句可以用来捕获大多数的异常，Rupk在Java层强制反射调用方法时，使用try-catch包裹住将要反射调用的方法，这么做显著的减少了Rupk在脱壳中的崩溃次数。

- 强制反射调用中的崩溃处理
  在强制反射调用中，并不是所有的崩溃都能够被try-catch捕获，比如由native层面产生的异常引发的崩溃。若每次崩溃后，Rupk在重启脱壳时都从头开始强制反射调用函数，会使脱壳效率低下。因此Rupk在运行过程中，记录下当前打开的dex文件的编号，当前反射调用方法所处类的编号以及方法相关信息。在Rupk因崩溃而重启后，从下一个方法处继续脱壳行为。


# Evaluation

我们使用XXX个覆盖20XX-20XX时间上的加壳样本对Rupk进行了测试。并与DexHunter, PackerGrind和DroidUnpack等脱壳系统进行了比较，讨论了这些系统的脱壳表现。最后，我们将揭露vmp在加壳服务中的使用情况，并解释为什么Rupk是通用的脱壳解决方案，尽管它无法应对vmp。
综上，为了评估Rupk的脱壳能力，我们提出了3个问题并将分别回答它们。

RQ1: Rupk脱壳能否应对现有的加壳服务？
RQ2: 与已有的脱壳系统相比，RUPK的表现如何？
RQ3: 加壳服务的主要加壳方式是什么？

A. Data Set
我们使用了两组加壳样本来评估Rupk。

- 样本集I
  样本集I是使用了最新(2019)加壳技术的加壳样本。F-Droid is an installable catalogue of FOSS (Free and Open Source Software) applications for the Android platform. 我们从F-Droid上随机下载了10(暂不确定)个开源应用，并分别将他们提交给了4个在线的商业加壳服务(Qihoo, Bangcle, Baidu, IJiami) in Aug.2019 to construct 40 packed apps.

  (tencent的Rupk无法处理，只能dump出部分代码)

- 样本集II
  样本集II是随机收集的覆盖了20XX-20XX时间上的加壳样本。应用程序在被加壳后，其文件结构会发生不同程度的变化。加壳服务通常会在APK文件中加入动态加载库，并通过JNI接口调用其中的函数。通过分析不同类型的加壳服务，我们归纳了这些加壳服务自身的动态库名称：

  百度 	  libbaiduprotect.so
  梆梆	  libSecShell.so, libsecexe.so 
  爱加密	 libexecmain.so, libexec.so
  360	    libjiagu.so
  Janus[30]是一个移动应用安全分析社区化平台，它收集了主流应用市场中应用程序的信息，并提供了一种自定义的规则语言来对数据库进行检索。我们通过搜索检测APK文件中是否包含上述特征动态库，来判断应用程序是否使用了加壳服务，以及加壳服务的具体名称，然后选取XX个加壳作为样本集II

B. 效果的判断

- 样本集I
  由于我们有样本集I应用的源码，因此判断Rupk在样本集I上的表现时，我们使用baksmali将Rupk重组还原出的Dex文件反编译成smali，使用apktool将应用源码变成smali，比较加壳前后的smali代码，检验Rupk的脱壳效果。
- 样本集II
  我们使用Baksmali反编译Rupk重组还原出的Dex文件，如果Baksmali能够正常的反编译，则Rupk能正确脱壳。反之，则Rupk不能正常脱壳。

C. 实验结果

- 样本集I
  表xxx展示了Rupk还原出的Dex文件在四家在线商业加壳服务中的方法还原率：

            方法总数    正确还原的方法    还原率
  Ijiami
  Baidu
  360
  梆梆

  通过实验，我们发现Rupk能够正确还原出被梆梆和Ijiami加壳过的应用。对于360和Baidu，Rupk分别还原出了xxx%和yyy%的代码。
  Ijiami加壳服务：
  新增了类 s/h/e/l/l/S和 s/h/e/l/l/N， s/h/e/l/l/N的onCreate作为加壳后的入口点，然后启动原应用
  
  Baidu加壳服务:
  新增了多个类，com/baidu/protect/StubApplication的onCreate作为加壳后的入口点，然后启动原应用。Baidu加壳服务将应用中的一些onCreate函数变成了下面的统一形式：
  .method protected onCreate(Landroid/os/Bundle;)V
    const v1, 0xa00000b
    const v3, 0x1
    new-array v0, v3, [Ljava/lang/Object;
    const v3, 0x0
    check-cast p1, Ljava/lang/Object;
    aput-object p1, v0, v3
    invoke-static {v1, p0, v0}, Lcom/baidu/protect/A;->V(ILjava/lang/Object;[Ljava/lang/Object;)V
    return-void
  .end method
  在这些onCreate函数中，都新建了一个类数组v0，将onCreate的参数放入到类数组中，然后以v1作为不同函数的标识，p0和v0调用Lcom/baidu/protect/A;->V，经过对Lcom/baidu/protect/A;->V的跟踪，我们发现，这是一个vmp。

  360加壳服务：
  com.stub.StubApp作为加壳后的入口点，然后启动原应用。360加壳服务将应用中的一些原本是onCreate的函数变成了native，在这些类中，其<clinit>函数变成了
  .method static constructor <clinit>()V
    const v0, 0x1389
    invoke-static {v0}, Lcom/stub/StubApp;->interface11(I)V
    return-void
  .end method
  其中v0用来标识不同的onCreate函数，用Lcom/stub/StubApp;->interface11(I)V将native onCreate进行注册。
 
  (
      在/proc/pid_of_process/maps内其实没有标出这段区间属于哪个so

      start : Lcom/perflyst/twire/activities/ChannelActivity; onCreate (Landroid/os/Bundle;)V
      native method 763233f1
      found
      76304000-763b3000 r-xp 0 

      start : Lcom/perflyst/twire/activities/SearchActivity; onCreate (Landroid/os/Bundle;)V
      native method 7642b3f1
      found
      7640c000-764bb000 r-xp 0 

      start : Lcom/perflyst/twire/activities/StartUpActivity; onCreate (Landroid/os/Bundle;)V
      native method 763233f1
      found
      76304000-763b3000 r-xp 0 
  )
  梆绑加壳服务：
  新增了一些类，Lcom/SecShell/SecShell/ApplicationWrapper作为加壳后的入口点，然后启动原应用。

  (xxxxxx中主要阐述加壳前后是否有新增类，没有还原出的代码是受vmp保护的，这个vmp的保护形式是什么)

- 样本集II
  表xxxx展示了Rupk还原出的Dex文件能否被Baksmali正常反编译，Native方法总数

                    Ijiami        Baidu       360       梆绑
  能否正常反编译
  Native方法总数

  通过手动对Rupk还原出的Dex文件反编译后的smali代码进行分析，我们发现了一些有趣的地方：
  梆绑有用过vmp, 此外还有字符串加密解密，这是和免费梆绑不同的点
  爱加密也有native OnCreate
  百度的自加密自解密样本
  某加壳在clinit处插入exit

  对RQ1的回答：通过使用样本集I和样本集II总计XXX个覆盖20XX-20XX时间上的加壳样本对Rupk进行了测试，测试结果说明，Rupk能够应对目前及以前的加壳服务。

D. 与现有脱壳工具的对比

DexHunter, 

嘴炮一下PackerGrind和DroidUnpack

Case Study

回答RQ2:
E. 对加壳服务的讨论





# Limitations and future work

介绍Rupk系统的局限性，耗时很长，只⽀持Android 4.4的dvm虚拟机。native代码的执⾏可以做更多的监控，强制反射调用时参数的填充可以更加的好，⽆法解决vmp壳。

# Related Work

介绍相关⼯作

# Conclusion

与Introduction中的贡献对照着写