# Abstract

近年来，Android加壳服务被广泛使用。为了分析被加壳的应用，研究者们提出了一系列脱壳方法。这些脱壳方法可分为两类：

第一类脱壳方法在应用运行到达一定状态后，转储内存，重新拼接得到脱壳后的dex。这类方法假设在某一状态，所有加密代码都被解密释放到内存。但如今，加壳服务已经实现运行阶段多层次解密，这类脱壳方法无法保证存在这样可以脱壳的特定状态并能成功触发该状态。

第二类脱壳方法通过监控加壳应用运行过程，在加壳服务释放真实代码或执行函数时，收集函数代码重组得到dex。但这类脱壳方法无法保证所有被加壳服务加密的代码在运行过程中都被释放或执行。因此脱壳得到的dex文件可能并不完整

为了解决目前脱壳方法中存在的问题，我们提出了一种全新的通用脱壳方法，并实现了Rupk系统。Rupk假设Android函数运行过程中，函数处于解密状态。为了让所有函数均被执行，Rupk创造性地强制执行所有函数，提高代码覆盖率。Rupk通过构建参数，反射调用目标函数，实现对目标函数的强制调用。在函数触发异常前，Rupk提取函数被还原后的代码，用于重组dex。同时，Rupk利用异常捕获机制，将崩溃次数降低到XXX%，并通过状态记录，在崩溃后重启应用，强制调用后续函数，继续脱壳进程。

在XXX个覆盖20XX-20XX时间上的加壳样本上进行实验，XXXX个方法中，XXX%方法能够被还原代码，证明了Rupk的有效性。进一步，我们实验还表明，Rupk还能处理以往脱壳系统无法处理的函数运行前解密、运行后加密的加壳方法。

<!-- 近年来，越来越多的Android恶意软件开始使用加壳服务。

为了分析被加壳的恶意软件，研究者们提出了一些脱壳方法。这些脱壳方法可分为两类：

第一类脱壳方法假定加壳服务会使用系统函数将真实代码释放到内存中，他们hook住这些系统函数，在函数内部转储内存，重组出dex文件。但如今，有些加壳服务使用自己编写的函数而不是系统函数来释放真实代码。此外，这类脱壳方法无法保证从内存转储得到的代码被完全解密。

第二类脱壳方法监控加壳应用的运行过程，当加壳应用释放出真实代码或者是执行方法时，这类脱壳方法收集代码重组出dex文件。这类脱壳方法无法保证所有被加壳服务加密的代码在运行过程中都被释放，也无法保证应用定义的所有方法在运行过程中都被执行。因此他们得到的dex文件可能不是完整的dex文件。

为了解决目前脱壳方法中存在的问题，我们提出了一种通用的脱壳方法，并实现了Rupk系统。该方法强制反射调用加壳应用定义的所有方法，由于加壳服务不能够干扰应用中的方法被反射调用，故真实的字节码在运行过程中会被释放。由于强制反射调用时无法提供合适的参数，因此方法可能会异常停止。但Rupk系统在方法异常中止前，已能收集到真实的代码，用以重组出dex文件。Rupk系统采用了异常捕获机制尽可能的减少应用崩溃，加速脱壳。

实验表明，Rupk系统能够有效的应对过去和现在的加壳服务，且能够避免现有脱壳方法中存在的问题。 -->

# Introduction

根据IDC的统计，2018年android手机的全球出货量在总出货量中的占比为85.1%，远超其他系统手机。由于android应用的可执行文件(dex文件)缺乏保护，很容易被攻击者逆向和篡改，加入恶意逻辑如资费消耗，隐私窃取等，再重打包分发到市场中，损害用户的权益。

为了保护Android应用免受逆向和篡改，出现了一系列的加壳服务。这些加壳服务使用多种手段隐藏原始的可执行文件(dex文件)，使得攻击者难以下手。但同时，一些加壳服务缺乏对提交应用的审计，使得恶意软件可以使用他们对自身进行加壳（引用DroidUnpack）。现有的恶意软件检测方法难以检测出被加壳的恶意软件。为了方便研究人员分析恶意软件，研究者们提出了一些脱壳方法。

在2015年，研究者们提出了⼀类脱壳方法，如AppSpear和DexHunter。

AppSpear注入Dalvik解释器，在方法执行时，获取方法对应的dex指针，转储该dex指针对应的内存还原出原始dex文件。

DexHunter注入defineClassNative函数，先获取dex指针，而后遍历dex中的每个类，在将类初始化后，转储对应的类内存，将类信息重新拼接成原始的dex文件。

这类方法的共同点是假设加壳应用运行的过程中存在一个合适的状态，所有加密代码都被解密释放到内存中，他们在此状态处转储内存，重新拼接得到脱壳后的dex。我们将这类方法称为基于合适状态(Right timing)的脱壳。这类方法刚出现时都取得了不错的脱壳效果，我们关心的是，随着加壳服务的发展，这类方法的效果如何？这里我们提出第一个问题：

**问题⼀：基于合适状态(Right timing)的脱壳还有效吗？如果无效，是什么原因所导致的**

近年来，研究者们新提出了一类脱壳方法，如DroidUnpack和PackerGrind。

DroidUnpack has been designed to monitor at the lowest level and reconstruct Java-level excution. 其关注应用运行时对于内存的读，写和运行操作，这使得DroidUnpack能够发现"write-and-then-exectute"的脱壳行为。DroidUnpack在监控过程中收集方法的代码。

PackerGrind propose a iterative process to unpack Android apps. 在每次迭代过程中，PackerGrind监控被加壳应用的运行。从数据收集点处收集和dex文件有关的数据并重组出dex文件，并生成分析报告。随后根据分析报告决定是否需要添加新的数据收集点和进行下一次迭代。

这类方法的共同点是监控加壳应用的运行，捕获加壳应用在运行过程中释放的真实代码。我们将这类方法称为基于监控的脱壳。是否成功脱壳的一个关键评价标准是代码覆盖率，这类方法很少有提到他们脱壳出的结果的代码覆盖率。这里我们提出第二个问题：

**问题二：基于监控的脱壳的代码覆盖率如何？这类脱壳系统能还原出原始应⽤的所有代码吗？**

我们对加壳应⽤作了⻓期的跟踪调查（从2015年到2019年），XXX⼩节揭示了，基于合适状态(Right timing)的脱壳和基于监控的脱壳都存在着各自的问题。基于合适状态(Right timing)的脱壳无法找到一个合适的状态，在此状态处内存中的代码都被解密。基于监控的脱壳则无法保证应用在运行过程中能释放所有被加密的代码。这里我们提出第三个问题：

**问题三：是否存在一种通用的脱壳方法，该方法能够避免目前脱壳方法中存在的问题？**

我们提出了一种全新的通用脱壳方法，并实现了Rupk系统。我们假设加壳服务不会影响应用内部对于已定义函数的正常反射调用，且函数运行过程中，会处于解密状态。现有的基于监控的脱壳方法监控加壳应用的运行，在加壳应用释放或是执行真实代码时才收集相关的数据，无法保证代码覆盖率。与其不同的是，Rupk系统通过构建参数，反射调用目标函数，实现对目标函数的强制调用。由于上下文环境或者参数不对，函数可能会触发异常。但在触发异常前，Rupk提取函数被还原后的代码，用于重组dex。同时，为了提升脱壳效率，Rupk利用异常捕获机制，将崩溃次数降低到XXX%，并通过状态记录，在崩溃后重启应用，强制调用后续函数，继续脱壳进程。

在XXX个覆盖20XX-20XX时间上的加壳样本上进行实验，XXXX个方法中，XXX%方法能够被还原代码，证明了Rupk的有效性。进一步，我们实验还表明，Rupk还能处理以往脱壳系统无法处理的函数运行前解密、运行后加密的加壳方法。

总结，我们的贡献如下：

- 通过对XXX个覆盖20XX-20XX时间上的加壳样本的调查，我们发现现有的脱壳方法都存在着各自的缺点。
- 我们提出了一种全新的通用脱壳方法，第一次将强制反射调用函数用在了脱壳上。我们实现了Rupk系统，该系统在强制反射调用函数时收集函数的代码，重组成原始的dex文件。此外，我们使用异常捕获机制提升了脱壳的效率。 
- 使用XXX个覆盖20XX-20XX时间上的加壳样本对Rupk系统进行测试，我们发现，Rupk系统的脱壳结果具有较高的代码覆盖率和准确性。此外，Rupk系统克服了现有脱壳方法中存在的问题，能够处理以往脱壳系统无法处理的函数运行前解密、运行后加密的加壳方法。

# BackGround

**安卓Java字节码**

**Java反射**

# Reflection Unpack System

## A. Key Idea

由于Java反射机制的存在，加壳服务要保证被加密了的方法能够被正常的反射调用，在反射调用的过程中，原始的Java字节码会暴露，Rupk系统监控方法的运行并收集字节码。

要想反射调用应用定义的所有⽅法，我们首先得找到基础的dex文件，应⽤可以从这个基础的dex⽂件处，完成反射操作。ReflectionUnpack在应⽤启动时侵入应⽤的进程，通过导出获得gDvm.loadedClasses缓存的dex文件，
在获得dex文件后，ReflectionUnpack通过类加载，获得dex文件中定义的每⼀个类，然后强制反射调⽤类中定义的每一个⽅法。然后监控方法的执⾏过程，在执⾏过程中，如果⼀个⽅法出现了变化，⽐如字节码发⽣了变化或者是从native方法变成了Java方法，则可认定出现了自修改⾏为，Rupk系统记录下字节码，供重组dex文件时使用。除此之外，Rupk系统也要检测native⽅法的指针来源，如果指针来自于壳so资源文件，则说明该⽅法被加壳服务动过手脚。Rupk系统记录下这些native⽅法。供研究⼈人员分析。

强制反射调⽤⽅法时，由于无法提供适当的参数，方法可能无法正常执行，出现异常而导致脱壳进程崩溃。Rupk系统尽可能的捕获异常，使得脱壳崩溃的次数尽可能的少。对于崩溃的情况，Rupk系统记录下崩溃的类号以及方法号，重启时从下⼀个⽅法开始反射调⽤。

## B. Rupk Overview

这部分内容给出Rupk系统的系统结构图。
系统是四个层次：系统启动层，应用层，监控执行层，崩溃重启层

系统启动层：

- 透明注⼊（transparent injection）
- ⽬标应用识别 (target identification)
- 提取器的加载 (extractior loading)

应⽤层：

- 获取dex文件 (dex locating)
- 类加载 (class loading)
- 强制反射调用方法 (method invoking)
- dex⽂件的重组 (dex recovring)

监控执行层

- Native⽅法的监控 (native method monitor)
- Java方法的监控 (java method monitor)

崩溃重启层

- 监控是否发⽣崩溃 (crash monitor)

## C.Design and implementation

分别详细的介绍四个层次的具体实现

系统启动层：

- **透明注⼊** (transparent injection）为了避开反调试， Rupk系统修改了java框架，使得所有应⽤启动时都会经过⼀段额外的代码，为注入做准备
- **⽬标应用识别** (target identification) 这段额外的代码检查包名，如果与本地固定位置储存的包名相同，说明是我们⽬标加壳应⽤
- **提取器的加载** (extractior loading) 然后启动保存在本地固定位置的so资源⽂件，这个资源⽂件是提取器，是应用层的⼊⼝

应用层：

- **获取dex文件** (dex locating) ⾸先从开放出的gdvm.loadedClasses中获取dex文件，然后获取缓存的类加载器
- **类加载** (class loading) 遍历dex⽂件中的每一个类，然后使用类加载器进行加载并初始化
- **强制反射调⽤⽅法** (method invoking) 然后强制反射调⽤类中定义的所有方法，⽅法的执⾏受到监控执⾏层的监控
- **dex文件的重组** (dex recovring) 监控执行层可以得到相应的字节码，结合dex⽂件中的string, proto_id等信息，重组出dex⽂文件

监控执行层：

- **Native⽅法的监控** (native method monitor) 如果当前所执行的是native方法，检查proc/id/maps,如果指向壳so文件，记录下来，给研究⼈员分析，可能是vmp方法。继续执行native方法，由于native方法可能是个自解密，最后会跳转到原始的java方法，因此执行native方法是有必要的

- **Java方法的监控** (java method monitor) 如果当前所执⾏的是java⽅法，则记录下java⽅法执⾏中的函数调用链，记录下其中的Java函数的字节码，并保存到本地，供重组dex⽂件时使用。

崩溃重启层

- **监控是否发生崩溃** (crash monitor) Java层的崩溃可以通过try catch捕获，native层的崩溃无法捕获，故每次强制反射调⽤方法时，记录下类号与⽅法号，当应⽤崩溃时，外部的脚本⾃动重启该加壳应用，重新进行脱壳，脱壳时，从当前类号的下一个⽅法号处继续脱壳。

# Evaluation

在这节中，我们将要回答以前所提出的三个问题

**问题⼀：内存脱壳还有效吗？如果⽆效，是什么原因所导致的**

**问题二：监控式脱壳系统的代码覆盖率如何？这类脱壳系统能还原出原始应用的所有代码吗？**

**问题三：是否存在一种通用的脱壳⽅法？**

我们将会使⽤样本集进⾏相应的实验，回答这三个问题。

A. 样本集

- 随机收集的样本(恶意样本) 2015~2019
- 已知源码的样本，然后送到⽬前的免费加壳服务上加壳 2019

B. 问题一：内存脱壳还有效吗？如果⽆效，是什么原因所导致的

由于Dexhunter与Appspear都是开源的，因此可以通过实验得出结论。 初步结论是，都⽆效，这部分的实验比较好做

C. 问题⼆：监控式脱壳系统的代码覆盖率如何？这类脱壳系统能还原出原始应用的所有代码吗？

PackerGrind提到的自身的弱点：

> PackerGrind can unpack apps protected by all mechanisms except the Re-implement Method.

Re-implement Method 即是百度的onCreate 

> PackerGrind can only recover the Dex data after the methods
for releasing the real code are invoked.

因此，只要找到样本，该样本存在加密方法，这个方法在应用简单运行时不会被释放即可。

DroidUnpack提到的自身的弱点：

> DroidUnpack certainly suffers from limited cover coverage as it can only dump the code that executes.  

这和PackerGrind有着微妙的不同，PackerGrind无法脱的样本DroidUnpack肯定没法脱，除此之外，如果一个应用在运行的时候不会运行到所有的方法，哪怕该方法没有被加密，DroidUnpack也脱不下来。

> And since it is built on top of whole-system emulation, packers that enforce anti-emulation techniques will inevitably break the analysis.

反模拟器的样本应该挺好找的。

D. 问题三：是否存在⼀种通用的脱壳方法？

有，我们提出了Rupk系统，下面就是要证明Rupk系统能够正确的脱壳。 使⽤两个样本集对Rupk系统进⾏全面的测试。看Rupk系统还原出的Java方法的⽐例。结论，Rupk系统的脱壳准确率⾮常⾼之类的。

E. ⽬前的加壳保护技术

这⾥介绍2019年各家加壳⼚商的加壳技术 : 内存加壳结合vmp。可以做case study。

# Limitations and future work

介绍Rupk系统的局限性，耗时很长，只⽀持Android 4.4的dvm虚拟机。native代码的执⾏可以做更多的监控，强制反射调用时参数的填充可以更加的好，⽆法解决vmp壳。

# Related Work

介绍相关⼯作

# Conclusion

与Introduction中的贡献对照着写