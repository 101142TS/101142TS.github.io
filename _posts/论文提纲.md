# Abstract

近年来，Android加壳服务被广泛使用。为了分析被加壳的应用，研究者们提出了一系列脱壳方法。这些脱壳方法可分为两类：

第一类脱壳方法在应用运行到达一定状态后，转储内存，重新拼接得到脱壳后的dex。这类方法假设在某一状态，所有加密代码都被解密释放到内存。但如今，加壳服务已经实现运行阶段多层次解密，这类脱壳方法无法保证存在这样可以脱壳的特定状态并能成功触发该状态。

第二类脱壳方法通过监控加壳应用运行过程，在加壳服务释放真实代码或执行函数时，收集函数代码重组得到dex。但这类脱壳方法无法保证所有被加壳服务加密的代码在运行过程中都被释放或执行。因此脱壳得到的dex文件可能并不完整

为了解决目前脱壳方法中存在的问题，我们提出了一种全新的通用脱壳方法，并实现了Rupk系统。Rupk假设Android函数运行过程中，函数处于解密状态。为了让所有函数均被执行，Rupk创造性地强制执行所有函数，提高代码覆盖率。Rupk通过构建参数，反射调用目标函数，实现对目标函数的强制调用。在函数触发异常前，Rupk提取函数被还原后的代码，用于重组dex。同时，Rupk利用异常捕获机制，将崩溃次数降低到XXX%，并通过状态记录，在崩溃后重启应用，强制调用后续函数，继续脱壳进程。

在XXX个覆盖20XX-20XX时间上的加壳样本上进行实验，XXXX个方法中，XXX%方法能够被还原代码，证明了Rupk的有效性。进一步，我们实验还表明，Rupk还能处理以往脱壳系统无法处理的函数运行前解密、运行后加密的加壳方法。

# Introduction

根据IDC的统计，2018年android手机的全球出货量在总出货量中的占比为85.1%，远超其他系统手机。由于android应用的可执行文件(dex文件)缺乏保护，很容易被攻击者逆向和篡改，加入恶意逻辑如资费消耗，隐私窃取等，再重打包分发到市场中，损害用户的权益。

为了保护Android应用免受逆向和篡改，出现了一系列的加壳服务。这些加壳服务使用多种手段隐藏原始的可执行文件(dex文件)，使得攻击者难以下手。但同时，一些加壳服务缺乏对提交应用的审计，使得恶意软件可以使用他们对自身进行加壳（引用DroidUnpack）。现有的恶意软件检测方法难以检测出被加壳的恶意软件。为了方便研究人员分析恶意软件，研究者们提出了一些脱壳方法。

在2015年，研究者们提出了⼀类脱壳方法，如AppSpear和DexHunter。

AppSpear注入Dalvik解释器，在方法执行时，获取方法对应的dex指针，转储该dex指针对应的内存还原出原始dex文件。

DexHunter注入defineClassNative函数，先获取dex指针，而后遍历dex中的每个类，在将类初始化后，转储对应的类内存，将类信息重新拼接成原始的dex文件。

这类方法的共同点是假设加壳应用运行的过程中存在一个合适的状态，所有加密代码都被解密释放到内存中，他们在此状态处转储内存，重新拼接得到脱壳后的dex。我们将这类方法称为基于合适状态(Right timing)的脱壳。这类方法刚出现时都取得了不错的脱壳效果，但如今，加壳服务已经实现运行阶段多层次解密，这类脱壳方法无法保证存在这样可以脱壳的特定状态并能成功触发该状态。

近年来，研究者们新提出了一类脱壳方法，如DroidUnpack和PackerGrind。

DroidUnpack has been designed to monitor at the lowest level and reconstruct Java-level excution. 其关注应用运行时对于内存的读，写和运行操作，这使得DroidUnpack能够发现"write-and-then-exectute"的脱壳行为。DroidUnpack在监控过程中收集方法的代码。

PackerGrind propose a iterative process to unpack Android apps. 在每次迭代过程中，PackerGrind监控被加壳应用的运行。从数据收集点处收集和dex文件有关的数据并重组出dex文件，并生成分析报告。随后根据分析报告决定是否需要添加新的数据收集点和进行下一次迭代。

这类方法的共同点是监控加壳应用的运行，捕获加壳应用在运行过程中释放的真实代码。我们将这类方法称为基于监控的脱壳。由于加壳服务不能够影响应用的正常运行，因此在运行的过程中，应用的函数会被解密。基于监控的脱壳能够取得不错的效果，因为其捕获到的一定是真实的函数代码。但其存在一个难以解决的问题：无法保证脱壳结果的代码覆盖率。

本文提出了一种全新的通用脱壳方法，并实现了Rupk系统。Rupk系统在应用函数运行的过程中对函数进行监控，收集函数的代码，重组还原成dex文件。Rupk系统的实现目的是克服以往脱壳系统中存在问题，这并不是一件容易的事，我们需要解决以下两个具有挑战性的问题：

**RQ1：如何保证代码覆盖率？**

就算传统的基于监控的脱壳系统使用IntelliDroid等工具触发函数的运行，
依然无法彻底的解决代码覆盖率的问题，这是他们系统设计所导致的。这类脱壳系统在脱壳的过程中扮演着被动的一方：他们被动的监控应用函数的运行。故无法保证脱壳得到的dex文件的完整性。为了保证代码覆盖率，Rupk系统通过构建参数，反射调用目标函数，实现对目标函数的强制调用。目标函数在强制执行的过程中，由于上下文环境或者参数不对，函数可能会触发异常。但在触发异常前，Rupk提取函数被还原后的代码，用于重组dex。通过对应用程序dex文件中定义了的函数的强制调用，Rupk系统可以保证代码覆盖率。

**RQ2：强制调用的函数可能会崩溃，频繁的崩溃会影响脱壳的速度，如何避免频繁的崩溃？**

函数的崩溃有两种形式，一种是在Java层面发生的崩溃，Rupk系统利用异常捕获机制，对这部分的崩溃进行捕获，使得这部分的崩溃不会影响Rupk系统继续脱壳。另一种是在native层面发生的崩溃，这部分的崩溃无法捕获，但Rupk系统通过状态记录，在崩溃后重启应用，强制调用后续函数，继续脱壳进程。且通过调查研究，我们发现，应用在native层面的崩溃次数非常的少，不足XXX%，对Rupk系统的脱壳速度不会造成太大的影响。

我们在XXX个覆盖20XX-20XX时间上的加壳样本上进行实验，XXXX个方法中，XXX%方法能够被还原代码，证明了Rupk的有效性。进一步，我们实验还表明，Rupk还能处理以往脱壳系统无法处理的函数运行前解密、运行后加密的加壳方法。此外，加壳服务存在着一个新的趋势：vmp加密在加壳服务中逐渐出现。

总结，我们的贡献如下：

- 我们提出了一种全新的通用脱壳方法并实现了Rupk系统，Rupk系统克服了现有脱壳方法中存在的问题。其第一次将强制反射调用函数用在了脱壳上。该系统在强制反射调用函数时收集函数的代码，重组成原始的dex文件。此外，我们使用异常捕获机制提升了脱壳的效率。 
- 使用XXX个覆盖20XX-20XX时间上的加壳样本对Rupk系统进行测试，我们发现，Rupk系统的脱壳结果具有较高的代码覆盖率和准确性。
- 通过对样本的分析和研究，我们发现Rupk系统能够处理以往脱壳系统无法处理的函数运行前解密、运行后加密的加壳方法。此外，vmp加密也在加壳服务中逐渐出现。

The rest of the paper is organized as follows. Section
II introduces xxxxx. Section III describes xxxx. Section IV details xxxx.

# BackGround

**安卓Java字节码**

**Java反射**

# Reflection Unpack System

## A. Key Idea

由于Java反射机制的存在，加壳服务要保证被加密了的方法能够被正常的反射调用，在反射调用的过程中，原始的Java字节码会暴露，Rupk系统监控方法的运行并收集字节码。

要想反射调用应用定义的所有⽅法，我们首先得找到基础的dex文件，应⽤可以从这个基础的dex⽂件处，完成反射操作。ReflectionUnpack在应⽤启动时侵入应⽤的进程，通过导出获得gDvm.loadedClasses缓存的dex文件，
在获得dex文件后，ReflectionUnpack通过类加载，获得dex文件中定义的每⼀个类，然后强制反射调⽤类中定义的每一个⽅法。然后监控方法的执⾏过程，在执⾏过程中，如果⼀个⽅法出现了变化，⽐如字节码发⽣了变化或者是从native方法变成了Java方法，则可认定出现了自修改⾏为，Rupk系统记录下字节码，供重组dex文件时使用。除此之外，Rupk系统也要检测native⽅法的指针来源，如果指针来自于壳so资源文件，则说明该⽅法被加壳服务动过手脚。Rupk系统记录下这些native⽅法。供研究⼈人员分析。

强制反射调⽤⽅法时，由于无法提供适当的参数，方法可能无法正常执行，出现异常而导致脱壳进程崩溃。Rupk系统尽可能的捕获异常，使得脱壳崩溃的次数尽可能的少。对于崩溃的情况，Rupk系统记录下崩溃的类号以及方法号，重启时从下⼀个⽅法开始反射调⽤。

## B. Rupk Overview

这部分内容给出Rupk系统的系统结构图。
系统是四个层次：系统启动层，应用层，监控执行层，崩溃重启层

系统启动层：

- 透明注⼊（transparent injection）
- ⽬标应用识别 (target identification)
- 提取器的加载 (extractior loading)

应⽤层：

- 获取dex文件 (dex locating)
- 类加载 (class loading)
- 强制反射调用方法 (method invoking)
- dex⽂件的重组 (dex recovring)

监控执行层

- Native⽅法的监控 (native method monitor)
- Java方法的监控 (java method monitor)

崩溃重启层

- 监控是否发⽣崩溃 (crash monitor)

## C.Design and implementation

分别详细的介绍四个层次的具体实现

系统启动层：

- **透明注⼊** (transparent injection）为了避开反调试， Rupk系统修改了java框架，使得所有应⽤启动时都会经过⼀段额外的代码，为注入做准备
- **⽬标应用识别** (target identification) 这段额外的代码检查包名，如果与本地固定位置储存的包名相同，说明是我们⽬标加壳应⽤
- **提取器的加载** (extractior loading) 然后启动保存在本地固定位置的so资源⽂件，这个资源⽂件是提取器，是应用层的⼊⼝

应用层：

- **获取dex文件** (dex locating) ⾸先从开放出的gdvm.loadedClasses中获取dex文件，然后获取缓存的类加载器
- **类加载** (class loading) 遍历dex⽂件中的每一个类，然后使用类加载器进行加载并初始化
- **强制反射调⽤⽅法** (method invoking) 然后强制反射调⽤类中定义的所有方法，⽅法的执⾏受到监控执⾏层的监控
- **dex文件的重组** (dex recovring) 监控执行层可以得到相应的字节码，结合dex⽂件中的string, proto_id等信息，重组出dex⽂文件

监控执行层：

- **Native⽅法的监控** (native method monitor) 如果当前所执行的是native方法，检查proc/id/maps,如果指向壳so文件，记录下来，给研究⼈员分析，可能是vmp方法。继续执行native方法，由于native方法可能是个自解密，最后会跳转到原始的java方法，因此执行native方法是有必要的

- **Java方法的监控** (java method monitor) 如果当前所执⾏的是java⽅法，则记录下java⽅法执⾏中的函数调用链，记录下其中的Java函数的字节码，并保存到本地，供重组dex⽂件时使用。

崩溃重启层

- **监控是否发生崩溃** (crash monitor) Java层的崩溃可以通过try catch捕获，native层的崩溃无法捕获，故每次强制反射调⽤方法时，记录下类号与⽅法号，当应⽤崩溃时，外部的脚本⾃动重启该加壳应用，重新进行脱壳，脱壳时，从当前类号的下一个⽅法号处继续脱壳。

# Evaluation

在这节中，我们将要回答以前所提出的三个问题

**问题⼀：内存脱壳还有效吗？如果⽆效，是什么原因所导致的**

**问题二：监控式脱壳系统的代码覆盖率如何？这类脱壳系统能还原出原始应用的所有代码吗？**

**问题三：是否存在一种通用的脱壳⽅法？**

我们将会使⽤样本集进⾏相应的实验，回答这三个问题。

A. 样本集

- 随机收集的样本(恶意样本) 2015~2019
- 已知源码的样本，然后送到⽬前的免费加壳服务上加壳 2019

B. 问题一：内存脱壳还有效吗？如果⽆效，是什么原因所导致的

由于Dexhunter与Appspear都是开源的，因此可以通过实验得出结论。 初步结论是，都⽆效，这部分的实验比较好做

C. 问题⼆：监控式脱壳系统的代码覆盖率如何？这类脱壳系统能还原出原始应用的所有代码吗？

PackerGrind提到的自身的弱点：

> PackerGrind can unpack apps protected by all mechanisms except the Re-implement Method.

Re-implement Method 即是百度的onCreate 

> PackerGrind can only recover the Dex data after the methods
for releasing the real code are invoked.

因此，只要找到样本，该样本存在加密方法，这个方法在应用简单运行时不会被释放即可。

DroidUnpack提到的自身的弱点：

> DroidUnpack certainly suffers from limited cover coverage as it can only dump the code that executes.  

这和PackerGrind有着微妙的不同，PackerGrind无法脱的样本DroidUnpack肯定没法脱，除此之外，如果一个应用在运行的时候不会运行到所有的方法，哪怕该方法没有被加密，DroidUnpack也脱不下来。

> And since it is built on top of whole-system emulation, packers that enforce anti-emulation techniques will inevitably break the analysis.

反模拟器的样本应该挺好找的。

D. 问题三：是否存在⼀种通用的脱壳方法？

有，我们提出了Rupk系统，下面就是要证明Rupk系统能够正确的脱壳。 使⽤两个样本集对Rupk系统进⾏全面的测试。看Rupk系统还原出的Java方法的⽐例。结论，Rupk系统的脱壳准确率⾮常⾼之类的。

E. ⽬前的加壳保护技术

这⾥介绍2019年各家加壳⼚商的加壳技术 : 内存加壳结合vmp。可以做case study。

# Limitations and future work

介绍Rupk系统的局限性，耗时很长，只⽀持Android 4.4的dvm虚拟机。native代码的执⾏可以做更多的监控，强制反射调用时参数的填充可以更加的好，⽆法解决vmp壳。

# Related Work

介绍相关⼯作

# Conclusion

与Introduction中的贡献对照着写