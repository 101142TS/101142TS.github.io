<!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <title>Abstart</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body>
        <h1 id="Abstart">Abstart</h1>
<p>近年来，加壳技术被⼴泛的用来保护Android软件，同时，恶意应用也可以使用加壳技术来防止⾃身被分析。</p>
<p>为了分析加壳技术，研究者们提出了一些脱壳系统。
这些脱壳系统都存在着代码覆盖率的问题，基于内存的脱壳系统⽆法保证重组的代码是被完全解密的。基于监控的脱壳系统无法保证被加密的函数会在应⽤运行过程中被执⾏，故他们可能会忽略掉这些函数。</p>
<p>因此，为了提升代码覆盖率，我们实现了ReflectionUnpack系统，ReflectionUnpack系统创新性的将Java的反射特性用在了脱壳当中。其反射调用类中定义的所有方法，方法为了正常执行必定会暴露原始字节码。系统收集这些字节码重组还原成dex文件。同时尽可能的捕获异常以减少崩溃。以方法为单位的脱壳可最有效的提升代码覆盖率。
实验表明，我们的系统能够有效的对抗⽬前市面上的加壳服务</p>
<h1 id="Introduction">Introduction</h1>
<p>安卓⼿机市场占用率比较高，报告显示安卓手机上的恶意软件非常多，这些恶意软件大多是正常应⽤被重打包，加入恶意逻辑。
为了保护安卓应用，出现了许多加壳服务，加壳服务可以保护应用免受重打包，同时，恶意软件制作者也可以使用加壳服务，使得恶意软件难以被分析。为了研究加壳的恶意软件，研究者们提出了一些脱壳系统。
在2015年时，研究者们提出了⼀类脱壳系统，如DexHunter和AppSpear，我们将这类脱壳系统称为内存式脱壳系统，这类脱壳系统假定在某个时间点处，加密的代码会被还原到内存中，这类脱壳系统从内存中收集这些代码并重组还原成dex文件。这里我们提出我们的第一个问题：</p>
<p><strong>问题⼀：内存脱壳还有效吗？如果无效，是什么原因所导致的</strong></p>
<p>近年来，研究者们新提出了一类脱壳系统，如DroidUnpack和PackerGrind，我们将这类脱壳
系统称为监控式脱壳系统。这类脱壳系统的特点是在目标应用运行时对其进⾏监控，
PackerGrind监控系统的函数，如dexFileParse,dvmInvokeMethod等，通过监控这些函数，PackerGrind收集到与dex文件有关的信息。DroidUnpack监控应⽤运行中对内存的操作，如果存在内存，这块内存先被写入，然后被执行，那么DroidUnpack就判定这是加壳服务释放的代码，将其记录。通过对信息的收集，这两类系统得以重组出原始的dex⽂件。这
⾥我们提出我们的第⼆个问题：</p>
<p><strong>问题二：监控式脱壳系统的代码覆盖率如何？这类脱壳系统能还原出原始应⽤的所有代码吗？</strong></p>
<p>我们对加壳应⽤作了⻓期的跟踪调查（从2015年到2019年），Evaluation⼩节揭示了，内存式脱壳和监控式脱壳⽆法彻底的解决应⽤加壳：他们脱出来的代码都有可能有未被解密的部分，即代码覆盖率不高。
这里提出第三个问题：</p>
<p><strong>问题三：是否存在一种通用的脱壳方法？</strong></p>
<p>为了解决⽬前脱壳研究中存在的问题，我们提出了ReflectionUnpack系统，该系统⼯作在Android 4.4的dalvik虚拟机上：</p>
<p>ReflectionUnpack系统第一次将Java语言中的反射引入到脱壳中，传统的脱壳往往以类为单位进行脱壳，无法保证类中的方法被完全解密。或者是监控应用所执行的方法，在执行时获取方法字节码，但这无法保证所有的方法都被执行，存在着代码覆盖率的问题。与他们不同的是，ReflectionUnpack系统将脱壳从被动转为主动，主动的反射调用所有的方法，由于Java的反射特性，加壳服务必须保证被反射调用的方法能够运行，由于无法给出合适的参数，被反射调用的方法可能会在途中出现异常，无法继续执行。但在此之前，ReflectionUnpack系统已获取该方法的真实字节码，用以重组dex文件。ReflectionUnpack系统也能捕获异常，尽可能的减少崩溃，加速脱壳。这种主动式脱壳技术能够覆盖到应用定义的所有方法，具有高度的代码覆盖率，能够解决除了vmp保护技术外的所有加壳技术。</p>
<p>通过在2015~2019年加壳样本上的测试，我们发现，已知加壳系统存在的问题，ReflectionUnpack都不存在，ReflectionUnpack能够全⾯的，准确的还原出原始dex⽂件。</p>
<p>总结，我们的贡献如下：</p>
<ul>
<li>我们设计并实现了ReflectionUnpack系统，该系统强制反射调用应⽤中定义的所有方法，在执⾏过程中收集相应的字节码，重组还原成dex⽂件。实验显示，ReflectionUnpack的脱壳效果⾮常好。</li>
<li>通过在2015~2019年加壳样本上的分析研究，我们发现现有的两类脱壳系统都存在着各自的问题。同时，我们发现了加壳服务的新趋势：内存加壳结合vmp加壳。</li>
</ul>
<h1 id="BackGround">BackGround</h1>
<p><strong>安卓Java字节码</strong></p>
<p><strong>Java反射</strong></p>
<h1 id="Reflection-Unpack-System">Reflection Unpack System</h1>
<h2 id="A-Key-Idea">A. Key Idea</h2>
<p>由于Java反射机制的存在，加壳服务要保证被加密了的方法能够被正常的反射调用，在反射调用的过程中，原始的Java字节码会暴露，Rupk系统监控方法的运行并收集字节码。</p>
<p>要想反射调用应用定义的所有⽅法，我们首先得找到基础的dex文件，应⽤可以从这个基础的dex⽂件处，完成反射操作。ReflectionUnpack在应⽤启动时侵入应⽤的进程，通过导出获得gDvm.loadedClasses缓存的dex文件，
在获得dex文件后，ReflectionUnpack通过类加载，获得dex文件中定义的每⼀个类，然后强制反射调⽤类中定义的每一个⽅法。然后监控方法的执⾏过程，在执⾏过程中，如果⼀个⽅法出现了变化，⽐如字节码发⽣了变化或者是从native方法变成了Java方法，则可认定出现了自修改⾏为，Rupk系统记录下字节码，供重组dex文件时使用。除此之外，Rupk系统也要检测native⽅法的指针来源，如果指针来自于壳so资源文件，则说明该⽅法被加壳服务动过手脚。Rupk系统记录下这些native⽅法。供研究⼈人员分析。</p>
<p>强制反射调⽤⽅法时，由于无法提供适当的参数，方法可能无法正常执行，出现异常而导致脱壳进程崩溃。Rupk系统尽可能的捕获异常，使得脱壳崩溃的次数尽可能的少。对于崩溃的情况，Rupk系统记录下崩溃的类号以及方法号，重启时从下⼀个⽅法开始反射调⽤。</p>
<h2 id="B-Rupk-Overview">B. Rupk Overview</h2>
<p>这部分内容给出Rupk系统的系统结构图。
系统是四个层次：系统启动层，应用层，监控执行层，崩溃重启层</p>
<p>系统启动层：</p>
<ul>
<li>透明注⼊（transparent injection）</li>
<li>⽬标应用识别 (target identification)</li>
<li>提取器的加载 (extractior loading)</li>
</ul>
<p>应⽤层：</p>
<ul>
<li>获取dex文件 (dex locating)</li>
<li>类加载 (class loading)</li>
<li>强制反射调用方法 (method invoking)</li>
<li>dex⽂件的重组 (dex recovring)</li>
</ul>
<p>监控执行层</p>
<ul>
<li>Native⽅法的监控 (native method monitor)</li>
<li>Java方法的监控 (java method monitor)</li>
</ul>
<p>崩溃重启层</p>
<ul>
<li>监控是否发⽣崩溃 (crash monitor)</li>
</ul>
<h2 id="CDesign-and-implementation">C.Design and implementation</h2>
<p>分别详细的介绍四个层次的具体实现</p>
<p>系统启动层：</p>
<ul>
<li><strong>透明注⼊</strong> (transparent injection）为了避开反调试， Rupk系统修改了java框架，使得所有应⽤启动时都会经过⼀段额外的代码，为注入做准备</li>
<li><strong>⽬标应用识别</strong> (target identification) 这段额外的代码检查包名，如果与本地固定位置储存的包名相同，说明是我们⽬标加壳应⽤</li>
<li><strong>提取器的加载</strong> (extractior loading) 然后启动保存在本地固定位置的so资源⽂件，这个资源⽂件是提取器，是应用层的⼊⼝</li>
</ul>
<p>应用层：</p>
<ul>
<li><strong>获取dex文件</strong> (dex locating) ⾸先从开放出的gdvm.loadedClasses中获取dex文件，然后获取缓存的类加载器</li>
<li><strong>类加载</strong> (class loading) 遍历dex⽂件中的每一个类，然后使用类加载器进行加载并初始化</li>
<li><strong>强制反射调⽤⽅法</strong> (method invoking) 然后强制反射调⽤类中定义的所有方法，⽅法的执⾏受到监控执⾏层的监控</li>
<li><strong>dex文件的重组</strong> (dex recovring) 监控执行层可以得到相应的字节码，结合dex⽂件中的string, proto_id等信息，重组出dex⽂文件</li>
</ul>
<p>监控执行层：</p>
<ul>
<li>
<p><strong>Native⽅法的监控</strong> (native method monitor) 如果当前所执行的是native方法，检查proc/id/maps,如果指向壳so文件，记录下来，给研究⼈员分析，可能是vmp方法。继续执行native方法，由于native方法可能是个自解密，最后会跳转到原始的java方法，因此执行native方法是有必要的</p>
</li>
<li>
<p><strong>Java方法的监控</strong> (java method monitor) 如果当前所执⾏的是java⽅法，则记录下java⽅法执⾏中的函数调用链，记录下其中的Java函数的字节码，并保存到本地，供重组dex⽂件时使用。</p>
</li>
</ul>
<p>崩溃重启层</p>
<ul>
<li><strong>监控是否发生崩溃</strong> (crash monitor) Java层的崩溃可以通过try catch捕获，native层的崩溃无法捕获，故每次强制反射调⽤方法时，记录下类号与⽅法号，当应⽤崩溃时，外部的脚本⾃动重启该加壳应用，重新进行脱壳，脱壳时，从当前类号的下一个⽅法号处继续脱壳。</li>
</ul>
<h1 id="Evaluation">Evaluation</h1>
<p>在这节中，我们将要回答以前所提出的三个问题</p>
<p><strong>问题⼀：内存脱壳还有效吗？如果⽆效，是什么原因所导致的</strong></p>
<p><strong>问题二：监控式脱壳系统的代码覆盖率如何？这类脱壳系统能还原出原始应用的所有代码吗？</strong></p>
<p><strong>问题三：是否存在一种通用的脱壳⽅法？</strong></p>
<p>我们将会使⽤样本集进⾏相应的实验，回答这三个问题。</p>
<p>A. 样本集</p>
<ul>
<li>随机收集的样本(恶意样本) 2015~2019</li>
<li>已知源码的样本，然后送到⽬前的免费加壳服务上加壳 2019</li>
</ul>
<p>B. 问题一：内存脱壳还有效吗？如果⽆效，是什么原因所导致的</p>
<p>由于Dexhunter与Appspear都是开源的，因此可以通过实验得出结论。 初步结论是，都⽆效，这部分的实验比较好做</p>
<p>C. 问题⼆：监控式脱壳系统的代码覆盖率如何？这类脱壳系统能还原出原始应用的所有代码吗？</p>
<p>PackerGrind提到的自身的弱点：</p>
<blockquote>
<p>PackerGrind can unpack apps protected by all mechanisms except the Re-implement Method.</p>
</blockquote>
<p>Re-implement Method 即是百度的onCreate</p>
<blockquote>
<p>PackerGrind can only recover the Dex data after the methods
for releasing the real code are invoked.</p>
</blockquote>
<p>因此，只要找到样本，该样本存在加密方法，这个方法在应用简单运行时不会被释放即可。</p>
<p>DroidUnpack提到的自身的弱点：</p>
<blockquote>
<p>DroidUnpack certainly suffers from limited cover coverage as it can only dump the code that executes.</p>
</blockquote>
<p>这和PackerGrind有着微妙的不同，PackerGrind无法脱的样本DroidUnpack肯定没法脱，除此之外，如果一个应用在运行的时候不会运行到所有的方法，哪怕该方法没有被加密，DroidUnpack也脱不下来。</p>
<blockquote>
<p>And since it is built on top of whole-system emulation, packers that enforce anti-emulation techniques will inevitably break the analysis.</p>
</blockquote>
<p>反模拟器的样本应该挺好找的。</p>
<p>D. 问题三：是否存在⼀种通用的脱壳方法？</p>
<p>有，我们提出了Rupk系统，下面就是要证明Rupk系统能够正确的脱壳。 使⽤两个样本集对Rupk系统进⾏全面的测试。看Rupk系统还原出的Java方法的⽐例。结论，Rupk系统的脱壳准确率⾮常⾼之类的。</p>
<p>E. ⽬前的加壳保护技术</p>
<p>这⾥介绍2019年各家加壳⼚商的加壳技术 : 内存加壳结合vmp。可以做case study。</p>
<h1 id="Limitations-and-future-work">Limitations and future work</h1>
<p>介绍Rupk系统的局限性，耗时很长，只⽀持Android 4.4的dvm虚拟机。native代码的执⾏可以做更多的监控，强制反射调用时参数的填充可以更加的好，⽆法解决vmp壳。</p>
<h1 id="Related-Work">Related Work</h1>
<p>介绍相关⼯作</p>
<h1 id="Conclusion">Conclusion</h1>
<p>与Introduction中的贡献对照着写</p>

    </body>
    </html>